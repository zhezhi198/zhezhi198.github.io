<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://zhezhi198.github.io</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://zhezhi198.github.io</link></image><lastBuildDate>Sun, 30 Nov 2025 15:33:54 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>牛客周赛 Round 120  部分</title><link>https://zhezhi198.github.io/post/niu-ke-zhou-sai-%20Round%20120%20%20-bu-fen.html</link><description>[进入比赛](https://ac.nowcoder.com/acm/contest/123788)

## E无穷无尽的树

&lt;img width='1263' height='1344' alt='Image' src='https://github.com/user-attachments/assets/86f848b9-007e-4552-938c-d65ae8cbcf3c' /&gt;

&gt;思路：树形dp即可，我们把叶子节点不予考虑即可。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/niu-ke-zhou-sai-%20Round%20120%20%20-bu-fen.html</guid><pubDate>Sun, 30 Nov 2025 15:33:28 +0000</pubDate></item><item><title>分块入门9题</title><link>https://zhezhi198.github.io/post/fen-kuai-ru-men-9-ti.html</link><description>## 数列分块入门1

&lt;img width='1263' height='1329' alt='Image' src='https://github.com/user-attachments/assets/ba9b3ade-2373-493e-a2a8-c0d527fd1700' /&gt;

&gt;第一题是y总的板子，但是y总的分块就讲了这个基础题目，我觉得还是太浅了，后来讲的就是链表分块，但是后来我去洛谷交了一个数据大一点点的题目，发现会卡常，还算不建议用y总的板子了

代码：
```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define debug(...) cout &lt;&lt; '[debug] ' #__VA_ARGS__ ' = ' &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#define out(x) cout &lt;&lt; ((x) ? 'YES' : 'NO') &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e5 + 10, M = 350, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
template &lt;typename T&gt;
struct BIT1
{
    int n;
    vector&lt;T&gt; tr;
    BIT1(int n) : n(n), tr(n + 1) {}
    void add(int x, T v)
    {
        for (; x &lt;= n; x += x &amp; -x)
            tr[x] += v;
    }
    T sum(int x)
    {
        T r = 0;
        for (; x; x -= x &amp; -x)
            r += tr[x];
        return r;
    }
    T range(int l, int r) { return sum(r) - sum(l - 1); }
};
template &lt;typename T&gt;
struct BIT2
{
    int n, m;
    vector&lt;vector&lt;T&gt;&gt; t1, t2, t3, t4;
    BIT2(int n_ = 0, int m_ = 0) { init(n_, m_); }
    void init(int n_, int m_)
    {
        n = n_;
        m = m_;
        t1.assign(n + 1, vector&lt;T&gt;(m + 1, T{}));
        t2.assign(n + 1, vector&lt;T&gt;(m + 1, T{}));
        t3.assign(n + 1, vector&lt;T&gt;(m + 1, T{}));
        t4.assign(n + 1, vector&lt;T&gt;(m + 1, T{}));
    }
    void _add(int x, int y, const T &amp;v)
    {
        for (int i = x; i &lt;= n; i += i &amp; -i)
            for (int j = y; j &lt;= m; j += j &amp; -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    void rangeAdd(int x1, int y1, int x2, int y2, const T &amp;v)
    {
        _add(x1, y1, v);
        _add(x1, y2 + 1, -v);
        _add(x2 + 1, y1, -v);
        _add(x2 + 1, y2 + 1, v);
    }
    T prefixSum(int x, int y)
    {
        T r{};
        for (int i = x; i &gt; 0; i -= i &amp; -i)
            for (int j = y; j &gt; 0; j -= j &amp; -j)
                r += t1[i][j] * (x + 1) * (y + 1) - t2[i][j] * (y + 1) - t3[i][j] * (x + 1) + t4[i][j];
        return r;
    }
    T rangeSum(int x1, int y1, int x2, int y2)
    {
        if (x1 &gt; x2 || y1 &gt; y2)
            return T{};
        return prefixSum(x2, y2) - prefixSum(x1 - 1, y2) - prefixSum(x2, y1 - 1) + prefixSum(x1 - 1, y1 - 1);
    }
};
struct Random
{
    mt19937_64 rng;
    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
    ll rand_ll(ll l, ll r) { return uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    int rand_int(int l, int r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng); }
    double rand_db(double l, double r) { return uniform_real_distribution&lt;double&gt;(l, r)(rng); }
    bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
    template &lt;typename T&gt;
    void shuffle(vector&lt;T&gt; &amp;v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
    ll res = 1 % p;
    a %= p;
    while (b)
    {
        if (b &amp; 1)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}
/*

*/
ll n, m, len;
ll a[N], add[M], sum[M];
ll get(ll i)
{
    return i / len;
}

void change(ll l, ll r, ll d)
{
    if (get(l) == get(r))
    {
        rep(i, l, r) a[i] += d, sum[get(i)] += d;
    }
    else
    {
        ll i = l, j = r;
        while (get(i) == get(l))
            a[i] += d, sum[get(i)] += d, i++;
        while (get(j) == get(r))
            a[j] += d, sum[get(j)] += d, j--;
        rep(k, get(i), get(j))
        {
            sum[k] += len * d;
            add[k] += d;
        }
    }
}

ll query(ll l, ll r)
{
    ll ret = 0;
    if (get(l) == get(r))
    {
        rep(i, l, r) ret += a[i] + add[get(i)];
    }
    else
    {
        ll i = l, j = r;
        while (get(i) == get(l))
            ret += a[i] + add[get(i)], i++;
        while (get(j) == get(r))
            ret += a[j] + add[get(j)], j--;
        rep(k, get(i), get(j))
        {
            ret += sum[k];
        }
    }
    return ret;
}

void solve()
{
    cin &gt;&gt; n ;
    m=n;
    rep(i, 1, n) cin &gt;&gt; a[i];
    len = sqrt(n);
    rep(i, 1, n)
    {
        sum[get(i)] += a[i];
    }
    while (m--)
    {
        string op;
        cin &gt;&gt; op;
        if (op == '0')
        {
            ll l, r, d;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;
            change(l, r, d);
        }
        else
        {
            ll l, r,d;
            cin &gt;&gt; l &gt;&gt; r&gt;&gt;d;
            ll ans = query(r, r);
            cout &lt;&lt; ans &lt;&lt; endl;
        }
    }
}

int main()
{
    IOS;

    int _ = 1;
    // cin&gt;&gt;_;//如果是多组数据
    while (_--)
    {
        solve();
    }
    return 0;
}
```
下面的是暂时不卡常的代码:
```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
//CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define debug(...) cout &lt;&lt; '[debug] ' #__VA_ARGS__ ' = ' &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#define out(x) cout &lt;&lt; ((x) ? 'YES' : 'NO') &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p&lt;&lt;1
#define rc p&lt;&lt;1|1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x)&amp;(-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps=1e-5;
const int N = 3e5 + 10,M=550,K=26;
const ll MOD = 1e9 + 7,Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template&lt;typename T&gt; bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template&lt;typename T&gt; bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template&lt;typename T&gt; void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
template&lt;typename T&gt; struct BIT1 { int n; vector&lt;T&gt; tr; BIT1(int n) : n(n), tr(n+1) {} void add(int x, T v) { for(;x&lt;=n;x+=x&amp;-x) tr[x]+=v; } T sum(int x) { T r=0; for(;x;x-=x&amp;-x) r+=tr[x]; return r; } T range(int l, int r) { return sum(r)-sum(l-1); } };
template&lt;typename T&gt; struct BIT2 { int n,m; vector&lt;vector&lt;T&gt;&gt; t1,t2,t3,t4; BIT2(int n_=0,int m_=0) { init(n_,m_); } void init(int n_,int m_) { n=n_; m=m_; t1.assign(n+1,vector&lt;T&gt;(m+1,T{})); t2.assign(n+1,vector&lt;T&gt;(m+1,T{})); t3.assign(n+1,vector&lt;T&gt;(m+1,T{})); t4.assign(n+1,vector&lt;T&gt;(m+1,T{})); } void _add(int x,int y,const T&amp; v) { for(int i=x;i&lt;=n;i+=i&amp;-i) for(int j=y;j&lt;=m;j+=j&amp;-j) { t1[i][j]+=v; t2[i][j]+=v*x; t3[i][j]+=v*y; t4[i][j]+=v*x*y; } } void rangeAdd(int x1,int y1,int x2,int y2,const T&amp; v) { _add(x1,y1,v); _add(x1,y2+1,-v); _add(x2+1,y1,-v); _add(x2+1,y2+1,v); } T prefixSum(int x,int y) { T r{}; for(int i=x;i&gt;0;i-=i&amp;-i) for(int j=y;j&gt;0;j-=j&amp;-j) r+=t1[i][j]*(x+1)*(y+1)-t2[i][j]*(y+1)-t3[i][j]*(x+1)+t4[i][j]; return r; } T rangeSum(int x1,int y1,int x2,int y2) { if(x1&gt;x2||y1&gt;y2) return T{}; return prefixSum(x2,y2)-prefixSum(x1-1,y2)-prefixSum(x2,y1-1)+prefixSum(x1-1,y1-1); } };
struct Random { mt19937_64 rng; Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {} ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); } ll rand_ll(ll l, ll r) { return uniform_int_distribution&lt;ll&gt;(l, r)(rng); } int rand_int(int l, int r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng); } double rand_db(double l, double r) { return uniform_real_distribution&lt;double&gt;(l, r)(rng); } bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); } template&lt;typename T&gt; void shuffle(vector&lt;T&gt; &amp;v) { std::shuffle(v.begin(), v.end(), rng); } };
ll qmi(ll a, ll b, ll p) { ll res = 1 % p; a %= p; while (b) { if (b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res; }
/*
  
*/
ll n, len;
ll a[N], add[M]; // 移除了不必要的sum数组

ll get(ll i) {
    return (i - 1) / len; // 通常块编号从0开始，或者用(i-1)/len +1从1开始，这里根据你的习惯调整。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/fen-kuai-ru-men-9-ti.html</guid><pubDate>Tue, 25 Nov 2025 07:35:02 +0000</pubDate></item><item><title>牛客练习赛146 部分题解</title><link>https://zhezhi198.github.io/post/niu-ke-lian-xi-sai-146%20-bu-fen-ti-jie.html</link><description>### 牛客练习赛146
[比赛链接](https://ac.nowcoder.com/acm/contest/122727#question)
&gt;想要写题解的题目：B,C,D,E..不够一下可能写不完慢慢更新

##  B小灰灰的火焰星球2
链接：https://ac.nowcoder.com/acm/contest/122727/B
来源：牛客网

&gt;在宇宙的最深处有一个神奇的星球，这个星球的形状类似一条直线，在这个星球的最左边（坐标为 0 处）有一个十分强力的火山，火山会影响这个星球的每一个地方的温度，温度会随着离火山的距离越远而越低。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/niu-ke-lian-xi-sai-146%20-bu-fen-ti-jie.html</guid><pubDate>Sat, 22 Nov 2025 08:42:28 +0000</pubDate></item><item><title>牛客小白月赛部分（C-&gt;F）</title><link>https://zhezhi198.github.io/post/niu-ke-xiao-bai-yue-sai-bu-fen-%EF%BC%88C--F%EF%BC%89.html</link><description>### 牛客小白月赛123
[点击进入比赛页面](https://ac.nowcoder.com/acm/contest/122725#question)

&gt;以后就讲有点思路的题目吧，A,B,就不讲了！

## C诗超绊

&lt;img width='943' height='855' alt='Image' src='https://github.com/user-attachments/assets/f5fa928e-6ef6-41bd-b848-c9714b2e5839' /&gt;

&gt;思路：我们要用至多  次区间加操作（每次加同一个固定正整数 ） 使序列严格递增。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/niu-ke-xiao-bai-yue-sai-bu-fen-%EF%BC%88C--F%EF%BC%89.html</guid><pubDate>Sat, 15 Nov 2025 02:53:30 +0000</pubDate></item><item><title>ABC 431部分题解</title><link>https://zhezhi198.github.io/post/ABC%20431-bu-fen-ti-jie.html</link><description>[比赛入口](https://atcoder.jp/contests/abc431/tasks)
&gt;A,B都写了，但是拿出来讲的意义不打就不太讨论，D题目感觉过于麻烦，我讲讲C,D,F三个题目吧,

### C - Robot Factory

&gt;题目面板如图所示:
#### 问题陈述

高桥可以将头部部件和身体部件组合成一个机器人。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/ABC%20431-bu-fen-ti-jie.html</guid><pubDate>Fri, 14 Nov 2025 10:39:37 +0000</pubDate></item><item><title>Codeforces Round 1062 (Div. 4) 题解</title><link>https://zhezhi198.github.io/post/Codeforces%20Round%201062%20%28Div.%204%29%20-ti-jie.html</link><description> ### Codeforces Round 1062
[点这里进入比赛页面](https://codeforces.com/contest/2167)
## A Square?
题意:
&gt;题目意思很简单，给定四个数大小的边，分别为a,b,c,d。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/Codeforces%20Round%201062%20%28Div.%204%29%20-ti-jie.html</guid><pubDate>Tue, 11 Nov 2025 08:31:10 +0000</pubDate></item><item><title>牛客周赛 Round 116 题解</title><link>https://zhezhi198.github.io/post/niu-ke-zhou-sai-%20Round%20116%20-ti-jie.html</link><description>### 牛客周赛 Round 116
[点这里进入比赛](https://ac.nowcoder.com/acm/contest/120553#question)

### A-小红的区间

&lt;img width='940' height='757' alt='Image' src='https://github.com/user-attachments/assets/0a7c960c-0bf3-4cd0-98cd-f87c95de8901' /&gt;

&gt;A题不多说，弄清楚相交，包含，相离的定义通过条件判断就可以解决这个题目

&gt;AC代码:
```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define out(x) cout &lt;&lt; ((x) ? 'YES' : 'NO') &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e5 + 10, M = 2 * N, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random
{
    mt19937_64 rng;
    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
    ll rand_ll(ll l, ll r) { return uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    int rand_int(int l, int r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng); }
    double rand_db(double l, double r) { return uniform_real_distribution&lt;double&gt;(l, r)(rng); }
    bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
    template &lt;typename T&gt;
    void shuffle(vector&lt;T&gt; &amp;v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
    ll res = 1 % p;
    a %= p;
    while (b)
    {
        if (b &amp; 1)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}
/*

*/

void solve()
{
    ll a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    if (c &lt; a &amp;&amp; d &gt; b)
    {
        cout &lt;&lt; 'A' &lt;&lt; endl;
    }
    else
        cout &lt;&lt; 'B' &lt;&lt; endl;
}

int main()
{
    IOS;

    int _ = 1;
    // cin&gt;&gt;_;//如果是多组数据
    while (_--)
    {
        solve();
    }
    return 0;
}
```

### B-小红的区间判断

&lt;img width='945' height='953' alt='Image' src='https://github.com/user-attachments/assets/a382e77b-7512-4484-9b15-b1af61a2e25a' /&gt;

&gt;B题和A题一样在这里直接给出代码

&gt;AC代码:
```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
	ios::sync_with_stdio(0); \
	cin.tie(0);              \
	cout.tie(0);
#define out(x) cout &lt;&lt; ((x) ? 'YES' : 'NO') &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e5 + 10, M = 2 * N, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random
{
	mt19937_64 rng;
	Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
	ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
	ll rand_ll(ll l, ll r) { return uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
	int rand_int(int l, int r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng); }
	double rand_db(double l, double r) { return uniform_real_distribution&lt;double&gt;(l, r)(rng); }
	bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
	template &lt;typename T&gt;
	void shuffle(vector&lt;T&gt; &amp;v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
	ll res = 1 % p;
	a %= p;
	while (b)
	{
		if (b &amp; 1)
			res = res * a % p;
		a = a * a % p;
		b &gt;&gt;= 1;
	}
	return res;
}
/*

*/

void solve()
{
	ll l1, r1, l2, r2;
	cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;
	if ((l2 &lt; l1 &amp;&amp; r1 &lt; r2) || (l1 &lt; l2 &amp;&amp; r2 &lt; r1))
	{
		cout &lt;&lt; 'A' &lt;&lt; endl;
	}
	else if (r1 &lt; l2 || l1 &gt; r2)
	{
		cout &lt;&lt; 'B' &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; 'C' &lt;&lt; endl;
	}
}

int main()
{
	IOS;

	int _ = 1;
	cin &gt;&gt; _; // 如果是多组数据
	while (_--)
	{
		solve();
	}
	return 0;
}
```
### C-小红的区间查询

&lt;img width='954' height='913' alt='Image' src='https://github.com/user-attachments/assets/5724a7c1-4c61-4c1d-b4f8-b7076f289c53' /&gt;

&gt;朴素的思路:
&gt;已知题目给出n个区间，然后q次询问，问我们每次询问的这个数是在第几个区间内，我们首先一个最朴素的想法就是，我们知道每个区间的l,r，我们可以利用差分数组在两个区间之间打上他们是第几个区间的值，比如他们是第一个区间。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/niu-ke-zhou-sai-%20Round%20116%20-ti-jie.html</guid><pubDate>Sat, 08 Nov 2025 06:36:47 +0000</pubDate></item><item><title>abc_430</title><link>https://zhezhi198.github.io/post/abc_430.html</link><description>[点这里进入比赛界面](https://atcoder.jp/contests/abc430)

### C - Truck Driver
&gt;核心问题分析


题目的要求是统计所有满足以下两个条件的子串 (l, r)：
1.a 的数量 &gt;= A
2.b 的数量 &lt; B

&gt; 思路:
问题要求统计所有满足两个条件的子串：1. 'a'的数量 ≥ A；2. 'b'的数量 &lt; B。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/abc_430.html</guid><pubDate>Thu, 06 Nov 2025 11:24:44 +0000</pubDate></item><item><title>test2</title><link>https://zhezhi198.github.io/post/test2.html</link><description>```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define out(x) cout &lt;&lt; ((x) ? 'YES' : 'NO') &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e5 + 10, M = 2 * N, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random
{
    mt19937_64 rng;
    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
    ll rand_ll(ll l, ll r) { return uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    int rand_int(int l, int r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng); }
    double rand_db(double l, double r) { return uniform_real_distribution&lt;double&gt;(l, r)(rng); }
    bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
    template &lt;typename T&gt;
    void shuffle(vector&lt;T&gt; &amp;v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
    ll res = 1 % p;
    a %= p;
    while (b)
    {
        if (b &amp; 1)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}

/*
    10 20 15
     9 8   6       -&gt;9 9 12
*/

void solve()
{
    ll n;
    cin &gt;&gt; n;
    vll a(n + 1, 0), b(n + 1, 0), preb(n + 1, 0);
    rep(i, 1, n) cin &gt;&gt; a[i];
    rep(i, 1, n) cin &gt;&gt; b[i];
    rep(i, 1, n) preb[i] = preb[i - 1] + b[i];
    vll d(n + 2, 0), sum(n + 2, 0);
    rep(i, 1, n)
    {
        ll tag = a[i] + preb[i - 1];
        auto it = lower_bound(preb.begin() + i, preb.end(), tag);
        auto k = it - preb.begin();
        if (k &lt;= n)
        {
            if (i &lt;= k - 1)
            {
                d[i]++;
                d[k]--;
            }
            ll rem = a[i] - (preb[k - 1] - preb[i - 1]);
            sum[k] += rem;
        }
        else
        {
            if (i &lt;= n)
            {
                d[i]++;
                d[n + 1]--;
            }
        }
    }
    rep(i, 1, n) d[i] += d[i - 1];
    rep(i, 1, n) cout &lt;&lt; d[i] * b[i] + sum[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
}

int main()
{
    IOS;

    int _ = 1;
    cin &gt;&gt; _; // 如果是多组数据
    while (_--)
    {
        solve();
    }
    return 0;
}
```
[点这里挑战题目](https://codeforces.com/contest/1795/problem/C)
// ch帅。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/test2.html</guid><pubDate>Sat, 25 Oct 2025 12:11:21 +0000</pubDate></item><item><title>test</title><link>https://zhezhi198.github.io/post/test.html</link><description>```cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define out(x) cout &lt;&lt; ((x) ? 'YES' : 'NO') &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e6 + 10, M = 1e7 + 10, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random
{
    mt19937_64 rng;
    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
    ll rand_ll(ll l, ll r) { return uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    int rand_int(int l, int r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng); }
    double rand_db(double l, double r) { return uniform_real_distribution&lt;double&gt;(l, r)(rng); }
    bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
    template &lt;typename T&gt;
    void shuffle(vector&lt;T&gt; &amp;v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
    ll res = 1 % p;
    a %= p;
    while (b)
    {
        if (b &amp; 1)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}
/*      题目 要求 ai&gt;=2  然后问满足任意(i,j)使得数组中gcd(a[i],a[j])==1
    但是你可以删去 数组中的元素 问最少删除多长 使得满足上面条件
    获得硬币 ai-1  支付硬币 ai+1
    3
  5 5 5   -&gt; 4 5 5 -&gt; 3 5 5 -&gt; 3 4 5  out 0

  4
  2 3 2 4   -&gt; 凑不出 -&gt;  2 3  out 2

  3
  2 100 2 -&gt; 2 3 97  out 0

   5
2 4 2 11 2   -&gt;2 3 4 10 -&gt;2 3 5 7 out 1
*/

ll prime[N], cnt = 0;
bool st[M];
ll sum[N];
void init()
{
    for (ll i = 2; i &lt; M; i++)
    {
        if (!st[i])
            prime[cnt++] = i;
        for (ll j = 0; prime[j] * i &lt; M &amp;&amp; j &lt; cnt; j++)
        {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0)
                break;
        }
    }
    rep(i, 0, cnt - 1)
    {
        sum[i + 1] = sum[i] + prime[i];
    }
}

void solve()
{
    ll n;
    cin &gt;&gt; n;
    vll a(n + 1, 0);
    ll summ = 0, num = 0;
    rep(i, 1, n) cin &gt;&gt; a[i], summ += a[i];
    sort_range(a, 1, n);
    rep(k, 0, n)
    {
        if (summ - num &gt;= sum[n - k])
        {
            cout &lt;&lt; k &lt;&lt; endl;
            return;
        }
        if (k &lt; n)
            num += a[k + 1];
    }
}

int main()
{
    IOS;
    int _ = 1;
    cin &gt;&gt; _; // 如果是多组数据
    init();
    while (_--)
    {
        solve();
    }
    return 0;
}
```。</description><guid isPermaLink="true">https://zhezhi198.github.io/post/test.html</guid><pubDate>Sat, 25 Oct 2025 12:05:16 +0000</pubDate></item></channel></rss>