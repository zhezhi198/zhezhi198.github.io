<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="[点这里进入比赛界面](https://atcoder.jp/contests/abc430)

### C - Truck Driver
>核心问题分析


题目的要求是统计所有满足以下两个条件的子串 (l, r)：
1.a 的数量 >= A
2.b 的数量 < B

> 思路:
问题要求统计所有满足两个条件的子串：1. 'a'的数量 ≥ A；2. 'b'的数量 < B。">
<meta property="og:title" content="abc_430">
<meta property="og:description" content="[点这里进入比赛界面](https://atcoder.jp/contests/abc430)

### C - Truck Driver
>核心问题分析


题目的要求是统计所有满足以下两个条件的子串 (l, r)：
1.a 的数量 >= A
2.b 的数量 < B

> 思路:
问题要求统计所有满足两个条件的子串：1. 'a'的数量 ≥ A；2. 'b'的数量 < B。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhezhi198.github.io/post/abc_430.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>abc_430</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">abc_430</h1>
<div class="title-right">
    <a href="https://zhezhi198.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/zhezhi198/zhezhi198.github.io/issues/3" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p><a href="https://atcoder.jp/contests/abc430" rel="nofollow">点这里进入比赛界面</a></p>
<h3>C - Truck Driver</h3>
<blockquote>
<p>核心问题分析</p>
</blockquote>
<p>题目的要求是统计所有满足以下两个条件的子串 (l, r)：<br>
1.a 的数量 &gt;= A<br>
2.b 的数量 &lt; B</p>
<blockquote>
<p>思路:<br>
问题要求统计所有满足两个条件的子串：1. 'a'的数量 ≥ A；2. 'b'的数量 &lt; B。<br>
面对 N 高达 3×10⁵ 的数据规模， O(N²) 的暴力枚举所有 (l, r) 区间显然会超时。题目的特点是，当我们固定一个左端点 i 并向右移动右端点 j 时，子串中 a 和 b 的数量都是单调增加的。这种单调性是使用 滑动窗口（或多指针） 算法来优化的关键信号。</p>
</blockquote>
<p>传统双指针的困境与三指针的引入</p>
<blockquote>
<p>传统的双指针 (l, r) 通常用于维护一个 同时满足所有条件 的“有效窗口”。但在这道题里，两个条件的方向不同：一个是“大于等于”（希望窗口更大），另一个是“小于”（希望窗口更小）。这导致对于一个固定的起点 i，合法的终点 j 不是一个点，而是一个连续的区间。</p>
</blockquote>
<blockquote>
<p>让我们把这个合法终点区间称为 [j_min, j_max]：<br>
*ja是第一个满足[i,j_min]中a的数量&gt;=A的位置。<br>
*jb是最后一个满足[i,j_max]中b的数量&lt;B的位置。<br>
只要我们为每个起点 i 找到这两个边界，那么对于这个 i，就有 max(0, j_max- j_min+1)个合法的子串。</p>
</blockquote>
<p>这自然而然地引出了三指针解法：</p>
<blockquote>
<p>i 指针 (起点指针): 在主循环中遍历，代表我们正在考察的子串的起点。<br>
l 指针 (下界指针): 它的任务是为当前的 i 找到 j_min。我们向右移动 ja，直到窗口 [i, ja-1] 首次满足 a 的数量 ≥ A。由于单调性，当 i 右移时，ja 无需回退，只需从当前位置继续右移即可。<br>
r 指针 (上界指针): 它的任务是为当前的 i 找到 j_max。我们向右移动 jb，直到窗口 [i, jb-1] 恰好满足 b 的数量 &lt; B，而窗口 [i, jb] 将要不满足条件。同样，jb 也无需回退。</p>
</blockquote>
<p>为什么是三个指针，而不是两个？</p>
<blockquote>
<p>因为传统双指针旨在寻找一个“最优解点”，而本题需要寻找一个“最优解区间”。一个 left 指针和 一个 right 指针可以定义一个窗口，但无法同时界定一个区间的两个端点。因此，我们需要一个指针 i 来锚定所有子串的起点，然后用另外两个指针 l 和 r 去“扫描”出合法终点区间的左右边界。这三个指针各司其职，共同协作，将寻找 [j_min, j_max] 的过程从 O(N) 优化到了均摊 O(1)，从而保证了整体 O(N) 的时间复杂度。</p>
</blockquote>
<blockquote>
<p>代码如下:</p>
</blockquote>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span>CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span> <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); cin.tie(<span class="pl-c1">0</span>); cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p&lt;&lt;<span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p&lt;&lt;<span class="pl-c1">1</span>|<span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x)&amp;(-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps=<span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">1e5</span> + <span class="pl-c1">10</span>,M=<span class="pl-c1">2</span>*N,K=<span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>,Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">struct</span> <span class="pl-en">Random</span> { mt19937_64 rng; Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {} ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); } ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); } <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); } <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); } <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); } <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); } };
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p) { ll res = <span class="pl-c1">1</span> % p; a %= p; <span class="pl-k">while</span> (b) { <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>) res = res * a % p; a = a * a % p; b &gt;&gt;= <span class="pl-c1">1</span>; } <span class="pl-k">return</span> res; }
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c">}</span>
<span class="pl-c"><span class="pl-c">*/</span></span>
	   
       
<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
	ll n,na,nb; cin&gt;&gt;n&gt;&gt;na&gt;&gt;nb;
	string s; cin&gt;&gt;s;
	s=<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>+s;
	ll cnta=<span class="pl-c1">0</span>,cntb=<span class="pl-c1">0</span>,ans=<span class="pl-c1">0</span>;<span class="pl-c"><span class="pl-c">//</span>记录区间内 a b字符的数量 ans记录合法的区间数</span>
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i = <span class="pl-c1">1</span>, ja = <span class="pl-c1">1</span>, jb = <span class="pl-c1">1</span>; i &lt;= n; i++)
	{
		<span class="pl-k">while</span>(ja&lt;=n&amp;&amp;cnta&lt;na)
		{
			cnta+=s[ja]==<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>;
			ja++;
		}
		<span class="pl-k">while</span>(jb&lt;=n&amp;&amp;cntb+(s[jb]==<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>)&lt;nb)
		{
			cntb += ((s[jb]==<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>));
			jb++;
		}
		<span class="pl-k">if</span>(cnta&gt;=na&amp;&amp;cntb&lt;nb&amp;&amp;ja&lt;=jb){
			ans+=jb-ja+<span class="pl-c1">1</span>;
		}
		 <span class="pl-c"><span class="pl-c">/*</span>*</span>
<span class="pl-c">         * 准备处理下一个起点(i+1)：从当前计数中移除起点i处的字符</span>
<span class="pl-c">         * 这是因为下一轮循环i会递增，窗口起点变为i+1</span>
<span class="pl-c">         * 需要从计数中移除不再属于新窗口的字符s[i]</span>
<span class="pl-c">         <span class="pl-c">*/</span></span>
		cnta-=(s[i]==<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>);
		cntb-=(s[i]==<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	 IOS; 
		
	<span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
	<span class="pl-c"><span class="pl-c">//</span> cin&gt;&gt;_;//如果是多组数据</span>
	<span class="pl-k">while</span> (_--)
	{
		<span class="pl-c1">solve</span>();
	}
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h3>D - Neighbor Distance</h3>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/afcd8d87-3227-43e6-9bbc-4eef1c2baa00"><img width="1793" height="1003" alt="Image" src="https://github.com/user-attachments/assets/afcd8d87-3227-43e6-9bbc-4eef1c2baa00" style="max-width: 100%; height: auto; max-height: 1003px;"></a></p>
这题思路简单就只需要正常模拟就行。
<p><a href="https://oi-wiki.org/lang/csl/associative-container/" rel="nofollow">容器不熟练的点这里复习</a></p>
<p>AC代码:</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">1e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">2</span> * N, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">struct</span> <span class="pl-en">Random</span>
{
    mt19937_64 rng;
    <span class="pl-en">Random</span>() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); }
    ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); }
    <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); }
    <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); }
    <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
    <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); }
};
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p)
{
    ll res = <span class="pl-c1">1</span> % p;
    a %= p;
    <span class="pl-k">while</span> (b)
    {
        <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> res;
}
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    ll n, res = <span class="pl-c1">0</span>, x;
    cin &gt;&gt; n;
    set&lt;ll&gt; st;
    map&lt;ll, ll&gt; mp;
    cin &gt;&gt; x;
    st.<span class="pl-c1">insert</span>(<span class="pl-c1">0</span>);
    st.<span class="pl-c1">insert</span>(x);
    mp[<span class="pl-c1">0</span>] = x;
    mp[x] = x;
    res += <span class="pl-c1">2</span> * x;
    cout &lt;&lt; res &lt;&lt; endl;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">1</span>; i &lt; n; i++)
    {
        cin &gt;&gt; x;
        vector&lt;ll&gt; h;
        <span class="pl-k">auto</span> it = st.<span class="pl-c1">lower_bound</span>(x);
        <span class="pl-k">if</span> (it != st.<span class="pl-c1">end</span>())
            h.<span class="pl-c1">push_back</span>(*it);
        <span class="pl-k">if</span> (it != st.<span class="pl-c1">begin</span>())
        {
            it--;
            h.<span class="pl-c1">push_back</span>(*it);
        }
        st.<span class="pl-c1">insert</span>(x);
        mp[x] = <span class="pl-c1">2e9</span>;
        <span class="pl-k">for</span> (<span class="pl-k">auto</span> &amp;nxt : h)
        {
            res -= mp[nxt];                       <span class="pl-c"><span class="pl-c">//</span> 从总和中去掉邻居旧的距离</span>
            mp[nxt] = <span class="pl-c1">min</span>(mp[nxt], <span class="pl-c1">abs</span>(nxt - x)); <span class="pl-c"><span class="pl-c">//</span> 更新邻居的距离</span>
            res += mp[nxt];                       <span class="pl-c"><span class="pl-c">//</span> 将邻居的新距离加回总和</span>
            mp[x] = <span class="pl-c1">min</span>(mp[x], <span class="pl-c1">abs</span>(nxt - x));
        }
        res += mp[x];
        cout &lt;&lt; res &lt;&lt; endl;
    }
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    <span class="pl-c"><span class="pl-c">//</span> cin&gt;&gt;_;//如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h3>E - Shift String</h3>
<p>题意:</p>
<blockquote>
<p>您将获得由‘ 0 ’和‘ 1 ’组成的长度相等的字符串 A 和 B 。A 可以执行0次或多次以下操作。—将 A 的第一个字符移到末尾。求生成 A=B 所需的最小操作数。如果无论你怎么操作都不能做出 A=B ，那就打印 −1 。给你 T 个测试用例；找出每个问题的答案。</p>
</blockquote>
<p>思路:</p>
<blockquote>
<p>我们先从最朴素的思路出发，操作是将A的第一个字符移动最后一个位置，显然这个过程具有周期性，我们不妨把A字符扩大一倍，然后控制首尾指针保证A串的长度，看看整个模拟过程是否有与B字符串相等的时候，如果没有输出-1，有则输出开头指针即可(默认字符串下标从1开始)。</p>
</blockquote>
<p>代码如下:</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span>CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span> <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); cin.tie(<span class="pl-c1">0</span>); cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p&lt;&lt;<span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p&lt;&lt;<span class="pl-c1">1</span>|<span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x)&amp;(-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps=<span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">2e6</span> + <span class="pl-c1">10</span>,M=<span class="pl-c1">2</span>*N,K=<span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>,Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">struct</span> <span class="pl-en">Random</span> { mt19937_64 rng; Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {} ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); } ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); } <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); } <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); } <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); } <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); } };
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p) { ll res = <span class="pl-c1">1</span> % p; a %= p; <span class="pl-k">while</span> (b) { <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>) res = res * a % p; a = a * a % p; b &gt;&gt;= <span class="pl-c1">1</span>; } <span class="pl-k">return</span> res; }
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	</span>
<span class="pl-c"><span class="pl-c">*/</span></span>
	   
       
<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
	string a,b; cin&gt;&gt;a&gt;&gt;b;
	ll n=a.<span class="pl-c1">size</span>();
	a+=a;
	ll cnt=-<span class="pl-c1">1</span>;
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">0</span>;i&lt;n;i++){
		string s=a.<span class="pl-c1">substr</span>(i,n);
		<span class="pl-k">if</span>(s==b){
			cnt=i;
			<span class="pl-k">break</span>;
		}
	}
	cout&lt;&lt;cnt&lt;&lt;endl;

}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	 IOS; 
		
	<span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
	 cin&gt;&gt;_;<span class="pl-c"><span class="pl-c">//</span>如果是多组数据</span>
	<span class="pl-k">while</span> (_--)
	{
		<span class="pl-c1">solve</span>();
	}
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>然而朴素的模拟会TLE，于是我们想到我们曾写过的KMP算法，用于主串与模式串的匹配，正好符合题意。由于题目比较板，不会复习一下KMP算法即可AC，这里不对思路做多余的赘述了。<br>
KMP解法如下:</p>
<pre lang="cpp#include" data-meta="&lt;bits/stdc++.h&gt;" class="notranslate"><code class="notranslate">using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
	ios::sync_with_stdio(0); \
	cin.tie(0);              \
	cout.tie(0);
#define out(x) cout &lt;&lt; ((x) ? "YES" : "NO") &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
// N 的大小需要足够容纳 ' ' + B + '#' + A + A
// |A| &lt;= 10^6, |B| &lt;= 10^6, |A+A| &lt;= 2*10^6
// 总长度约为 1 + 10^6 + 1 + 2*10^6 = 3*10^6 + 2, 所以 N 开大一点
const int N = 3e6 + 20;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random
{
	mt19937_64 rng;
	Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
	ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
	ll rand_ll(ll l, ll r) { return uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
	int rand_int(int l, int r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng); }
	double rand_db(double l, double r) { return uniform_real_distribution&lt;double&gt;(l, r)(rng); }
	bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
	template &lt;typename T&gt;
	void shuffle(vector&lt;T&gt; &amp;v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
	ll res = 1 % p;
	a %= p;
	while (b)
	{
		if (b &amp; 1)
			res = res * a % p;
		a = a * a % p;
		b &gt;&gt;= 1;
	}
	return res;
}

int pi[N];

void solve()
{
	string a, b;
	cin &gt;&gt; a &gt;&gt; b;

	if (a.size() != b.size())
	{
		cout &lt;&lt; -1 &lt;&lt; endl;
		return;
	}

	string t = a + a;
	string p = b;
	int m = p.size();
	if (m == 0)
	{
		cout &lt;&lt; 0 &lt;&lt; endl;
		return;
	}
	string s = " " + p + '#' + t;
	int lens = s.size() - 1;
	for (int i = 0; i &lt;= lens; i++)  pi[i] = 0;
	
	for (int i = 2, j = 0; i &lt;= lens; i++)
	{
		while (j &gt; 0 &amp;&amp; s[i] != s[j + 1])
		{
			j = pi[j];
		}
		if (s[i] == s[j + 1])
		{
			j++;
		}
		pi[i] = j;

		if (pi[i] == m)
		{

			int pos = i - 2 * m - 1;

			if (pos &lt; m)
			{
				cout &lt;&lt; pos &lt;&lt; endl;
				return;
			}
		}
	}

	cout &lt;&lt; -1 &lt;&lt; endl;
}

int main()
{
	IOS;

	int T = 1;
	cin &gt;&gt; T; // 如果是多组数据
	while (T--)
	{
		solve();
	}
	return 0;
}

</code></pre>
<p><a href="https://oi-wiki.org/string/kmp/" rel="nofollow">KMP算法介绍</a></p>
<p>由于我的KMP板子在其他博客难以查到，后续有时间再单独写一篇自己KMP的算法专栏，考虑到当前只是想写题解，这个后续有时间再补。</p>
<p>另外一种解法:</p>
<blockquote>
<p>双哈希解法：高效的模式匹配利器<br>
在解决了朴素模拟法的效率瓶颈后，我们还可以利用双哈希技术来优化此问题。这种方法的核心思想是：通过计算两个独立的哈希值来代表字符串，当且仅当两个哈希值都匹配时，才判定子串相等，从而将哈希冲突的概率降至极低水平（约为两个哈希函数单独冲突概率的乘积）<br>
那么思路就很简单了，预处理一下用B串来匹配一下即可。</p>
</blockquote>
<p><a href="https://blog.csdn.net/sin1810335764/article/details/136158507?ops_request_misc=%257B%2522request%255Fid%2522%253A%252276daf00b3a3a0f0d7f084af87588d57f%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=76daf00b3a3a0f0d7f084af87588d57f&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-136158507-null-null.142%5Ev102%5Epc_search_result_base1&amp;utm_term=%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8C%E5%93%88%E5%B8%8C&amp;spm=1018.2226.3001.4187" rel="nofollow">不理解哈希或者双哈希的可以看看这个</a></p>
<blockquote>
<p>双哈希解法如下（附带部分注释）:</p>
</blockquote>
<pre lang="cpp#include" data-meta="&lt;bits/stdc++.h&gt;" class="notranslate"><code class="notranslate">using namespace std;
// CJX__//
typedef long long ll;
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define out(x) cout &lt;&lt; ((x) ? "YES" : "NO") &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 2e6 + 10;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random
{
    mt19937_64 rng;
    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
    ll rand_ll(ll l, ll r) { return uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    int rand_int(int l, int r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng); }
    double rand_db(double l, double r) { return uniform_real_distribution&lt;double&gt;(l, r)(rng); }
    bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
    template &lt;typename T&gt;
    void shuffle(vector&lt;T&gt; &amp;v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
    ll res = 1 % p;
    a %= p;
    while (b)
    {
        if (b &amp; 1)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}

/*
 h1: 第一个哈希函数的前缀哈希值数组（使用unsigned long long，利用自然溢出）
p1: 存储base1的幂次，用于快速计算子串哈希值
 h2: 第二个哈希函数的前缀哈希值数组（使用long long，手动取模）
 p2: 存储base2的幂次
*/
ull h1[N], p1[N];
ll h2[N], p2[N];

// 预处理函数
void pre(int len) {
    p1[0] = 1;
    p2[0] = 1;
    for (int i = 1; i &lt;= len; i++) {
        p1[i] = p1[i-1] * base1;
        p2[i] = mod(p2[i-1] * base2, Md7);
    }
}

/*
获取子串哈希值
 	l: 子串起始位置
  	r: 子串结束位置
 	len: 子串长度（r-l+1）
*/

PLL get_hash(int l, int r, int len) {
    ull v1 = h1[r] - h1[l-1] * p1[len];
    ll v2 = mod(h2[r] - mod(h2[l-1] * p2[len], Md7), Md7);
    return {v1, v2};
}

void solve()
{
    string a, b; 
    cin &gt;&gt; a &gt;&gt; b;

    int n = a.size();
    if (n != b.size()) {
        cout &lt;&lt; -1 &lt;&lt; endl;
        return;
    }
    
    if (n == 0) {
        cout &lt;&lt; 0 &lt;&lt; endl;
        return;
    }

    ull bh1 = 0;// b的第一个哈希值
    ll bh2 = 0;// b的第二个哈希值
    for (char c : b) {
		// 滚动哈希计算：新哈希值 = 旧哈希值 * base + 当前字符
        bh1 = bh1 * base1 + c;
        bh2 = mod(bh2 * base2 + c, Md7);
    }

    string s = a + a;
    
    h1[0] = h2[0] = 0;// 计算s的前缀哈希
    for (int i = 0; i &lt; s.size(); i++) {
        h1[i+1] = h1[i] * base1 + s[i];
        h2[i+1] = mod(h2[i] * base2 + s[i], Md7);
    }

    // 查找匹配
    for (int i = 0; i &lt; n; i++) {
        PLL hv = get_hash(i+1, i+n, n);
        if (hv.fi == bh1 &amp;&amp; hv.se == bh2) {
            cout &lt;&lt; i &lt;&lt; endl;
            return;
        }
    }

    cout &lt;&lt; -1 &lt;&lt; endl;
}

int main()
{
    IOS;
    pre(2000000); 
    int T = 1;
    cin &gt;&gt; T;
    while (T--)
    {
        solve();
    }
    return 0;
}
</code></pre></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://zhezhi198.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);
cmButton=document.getElementById("cmButton");
    span=document.createElement("span");
    span.setAttribute("class","Counter");
    span.innerHTML="2";
    cmButton.appendChild(span);


function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","zhezhi198/zhezhi198.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
