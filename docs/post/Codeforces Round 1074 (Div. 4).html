<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="[进入比赛](https://codeforces.com/contest/2185)
# A. 完美的根 

**时间限制：** 1 秒  
**内存限制：** 256 MB  
**输入：** 标准输入  
**输出：** 标准输出  

## 题目描述

如果存在一个整数 $y$ 使得 $\sqrt{y} = x$，则正整数 $x$ 被称为一个**完全根**。">
<meta property="og:title" content="Codeforces Round 1074 (Div. 4)">
<meta property="og:description" content="[进入比赛](https://codeforces.com/contest/2185)
# A. 完美的根 

**时间限制：** 1 秒  
**内存限制：** 256 MB  
**输入：** 标准输入  
**输出：** 标准输出  

## 题目描述

如果存在一个整数 $y$ 使得 $\sqrt{y} = x$，则正整数 $x$ 被称为一个**完全根**。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhezhi198.github.io/post/Codeforces%20Round%201074%20%28Div.%204%29.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>Codeforces Round 1074 (Div. 4)</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Codeforces Round 1074 (Div. 4)</h1>
<div class="title-right">
    <a href="https://zhezhi198.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/zhezhi198/zhezhi198.github.io/issues/18" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p><a href="https://codeforces.com/contest/2185" rel="nofollow">进入比赛</a></p>
<h1>A. 完美的根</h1>
<p><strong>时间限制：</strong> 1 秒<br>
<strong>内存限制：</strong> 256 MB<br>
<strong>输入：</strong> 标准输入<br>
<strong>输出：</strong> 标准输出</p>
<h2>题目描述</h2>
<p>如果存在一个整数 $y$ 使得 $\sqrt{y} = x$，则正整数 $x$ 被称为一个<strong>完全根</strong>。</p>
<p>例如，5 是一个完全根，因为 $\sqrt{25} = 5$。</p>
<p>对于每个测试用例，请输出 $n$ 个<strong>不同</strong>的完全根。<br>
注意：这些值只需要在当前测试用例中互不相同即可；在不同的测试用例中，你可以重复使用相同的值。</p>
<h3>输入格式</h3>
<p>输入的第一行包含一个整数 $t$ ($1 \le t \le 20$) —— 测试用例的数量。</p>
<p>每个测试用例只有一行，包含一个整数 $n$ ($1 \le n \le 20$) —— 需要输出的完全根的个数。</p>
<h3>输出格式</h3>
<p>对于每个测试用例，输出 $n$ 个不同的完全根。每个完全根 $x$ 必须在 $1 \le x \le 10^9$ 的范围内。</p>
<h2>样例</h2>
<p><strong>输入</strong></p>
<pre lang="text" class="notranslate"><code class="notranslate">3
1
2
5
</code></pre>
<p><strong>输出</strong></p>
<pre lang="text" class="notranslate"><code class="notranslate">1
2 4
2 102 43 1 21
</code></pre>
<blockquote>
<p>正数n是n*n的一个平方根，直接输出n个正数就行。<br>
代码:</p>
</blockquote>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">1e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">2</span> * N, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>
ll n;
<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    cin &gt;&gt; n;
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n) cout &lt;&lt; i &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
    cout &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    cin &gt;&gt; _; <span class="pl-c"><span class="pl-c">//</span> 如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h1>B. 前缀最大值</h1>
<p><strong>时间限制：</strong> 1.5 秒<br>
<strong>内存限制：</strong> 256 MB<br>
<strong>输入：</strong> 标准输入<br>
<strong>输出：</strong> 标准输出</p>
<h2>题目描述</h2>
<p>给定一个包含 $n$ 个整数的数组 $a_1, a_2, \dots, a_n$。</p>
<p>定义一个数组的**“值”**为该数组每个前缀的最大值之和。<br>
更正式地说，数组 $a$ 的值为：<br>
$$\sum_{i=1}^{n} \max(a_1, \dots, a_i)$$</p>
<p>例如，数组 $[1, 2, 1]$ 的值为：<br>
$$\max(1) + \max(1, 2) + \max(1, 2, 1) = 1 + 2 + 2 = 5$$</p>
<p>你可以选择两个下标 $i$ 和 $j$ 并交换元素 $a_i$ 和 $a_j$。<strong>这个操作最多只能执行一次</strong>（也可以不执行）。</p>
<p>请找出在执行最多一次操作后，数组 $a$ 可能达到的<strong>最大值</strong>。</p>
<h3>输入格式</h3>
<p>输入的第一行包含一个整数 $t$ ($1 \le t \le 100$) —— 测试用例的数量。</p>
<p>每个测试用例的第一行包含一个整数 $n$ ($2 \le n \le 50$) —— 数组 $a$ 的长度。</p>
<p>第二行包含 $n$ 个整数 $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^4$) —— 数组 $a$ 的元素。</p>
<h3>输出格式</h3>
<p>对于每个测试用例，输出执行交换操作（或不交换）后，数组 $a$ 能达到的最大可能值。</p>
<h2>样例</h2>
<p><strong>输入</strong></p>
<pre lang="text" class="notranslate"><code class="notranslate">4
5
2 1 4 5 3
2
5 1
3
3 2 1
2
6 7
</code></pre>
<p><strong>输出</strong></p>
<pre lang="text" class="notranslate"><code class="notranslate">25
10
9
14
</code></pre>
<blockquote>
<p>很明显把最大值用最多次，放在数组第一个位置就可以了。<br>
代码:</p>
</blockquote>
<pre class="notranslate"><code class="notranslate">cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define debug(...) cout &lt;&lt; "[debug] " #__VA_ARGS__ " = " &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#define out(x) cout &lt;&lt; ((x) ? "YES" : "NO") &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e5 + 10, M = 2 * N, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
/*

*/

void solve()
{
    ll n;
    cin &gt;&gt; n;
    ll mx = 0;
    rep(i, 1, n)
    {
        ll x;
        cin &gt;&gt; x;
        cmax(mx, x);
    }
    cout &lt;&lt; mx * n &lt;&lt; endl;
}

int main()
{
    IOS;

    int _ = 1;
    cin &gt;&gt; _; // 如果是多组数据
    while (_--)
    {
        solve();
    }
    return 0;
}
</code></pre>
<h1>C. 移位 MEX</h1>
<p><strong>时间限制：</strong> 2 秒<br>
<strong>内存限制：</strong> 256 MB<br>
<strong>输入：</strong> 标准输入<br>
<strong>输出：</strong> 标准输出</p>
<h2>题目描述</h2>
<p>给定一个包含 $n$ 个整数的数组 $a_1, a_2, \dots, a_n$。你允许执行以下操作<strong>一次</strong>：</p>
<p>选择一个整数 $x$（可以是负数），然后对于每一个 $i$ ($1 \le i \le n$)，将 $a_i$ 更新为 $a_i + x$。</p>
<p>例如，如果 $a = [1, 3, 4, 2]$，并且你选择 $x = 3$ 执行操作，那么数组 $a$ 将变为 $[4, 6, 7, 5]$。</p>
<p>请输出在执行完操作后，数组的 $\text{MEX}(a)$ 可能达到的<strong>最大值</strong>。</p>
<blockquote>
<p><strong>MEX 定义：</strong><br>
<strong>MEX(a)</strong> 定义为数组中<strong>不包含</strong>的最小非负整数。<br>
例如：<code class="notranslate">MEX([1, 2, 0, 5]) = 3</code>，<code class="notranslate">MEX([1, 2, 4, 9]) = 0</code>。</p>
</blockquote>
<h3>输入格式</h3>
<p>输入的第一行包含一个整数 $t$ ($1 \le t \le 1000$) —— 测试用例的数量。</p>
<p>每个测试用例的第一行包含一个整数 $n$ ($1 \le n \le 3000$) —— 数组 $a$ 的长度。</p>
<p>第二行包含 $n$ 个整数 $a_1, a_2, \dots, a_n$ ($-10^9 \le a_i \le 10^9$) —— 数组 $a$ 的元素。</p>
<p>保证所有测试用例中 $n$ 的总和不超过 $3000$。</p>
<h3>输出格式</h3>
<p>对于每个测试用例，输出操作执行后 $\text{MEX}(a)$ 的最大可能值。</p>
<h2>样例</h2>
<p><strong>输入</strong></p>
<pre lang="text" class="notranslate"><code class="notranslate">6
1
4
5
0 1 1 2 3
2
1 1
4
4 2 3 6
5
2 4 1 0 -1
6
-1 1 2 3 5 6
</code></pre>
<p><strong>输出</strong></p>
<pre lang="text" class="notranslate"><code class="notranslate">1
4
1
3
4
3
</code></pre>
<blockquote>
<p>思路:给数组中每个值+x相当于把平移值轴，根据mex的性质，显然既然可以平移，那么mex的值可以转换为最长连续数组的长度吗？<br>
代码：</p>
</blockquote>
<pre class="notranslate"><code class="notranslate">cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define debug(...) cout &lt;&lt; "[debug] " #__VA_ARGS__ " = " &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#define out(x) cout &lt;&lt; ((x) ? "YES" : "NO") &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e5 + 10, M = 2 * N, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
/*

*/

void solve()
{
    ll n;
    cin &gt;&gt; n;
    vll a(n + 1, 0);
    rep(i, 1, n) cin &gt;&gt; a[i];
    sort_range(a, 1, n);
    ll len = 1, mx = 1;
    rep(i, 2, n)
    {

        if (a[i] == a[i - 1])
            continue;
        else if (a[i] == a[i - 1] + 1)
        {
            len++;
            cmax(mx, len);
        }
        else
        {
            len = 1;
        }
     }
    cout &lt;&lt; mx &lt;&lt; endl;
}

int main()
{
    IOS;

    int _ = 1;
    cin &gt;&gt; _; // 如果是多组数据
    while (_--)
    {
        solve();
    }
    return 0;
}
</code></pre>
<h1>D. 内存溢出</h1>
<p><strong>时间限制：</strong> 2 秒<br>
<strong>内存限制：</strong> 256 MB<br>
<strong>输入：</strong> 标准输入<br>
<strong>输出：</strong> 标准输出</p>
<h2>题目描述</h2>
<p>Bessie 有一个包含 $n$ 个整数的数组 $a_1, a_2, \dots, a_n$。<br>
她会对数组执行 $m$ 次操作。第 $i$ 次操作将 $a_{b_i}$ 修改为 $a_{b_i} + c_i$。</p>
<p>不幸的是，由于内存成本上升，Bessie 的计算机内存有限。<br>
如果在<strong>任何时候</strong>数组中的<strong>任意</strong>元素大于 $h$，她的计算机就会崩溃，并且数组中的<strong>每个元素都会被重置为初始值</strong>。<br>
（注意：崩溃后，导致崩溃的那次操作及之前的所有操作效果都消失了，系统重新从下一次操作开始计算）。</p>
<p>请输出在所有操作执行完毕后，数组 $a$ 的最终状态。</p>
<h3>输入格式</h3>
<p>输入的第一行包含一个整数 $t$ ($1 \le t \le 10^4$) —— 测试用例的数量。</p>
<p>每个测试用例的第一行包含三个整数 $n, m, h$ ($1 \le n, m \le 2 \cdot 10^5, 1 \le h \le 10^9$) —— 数组 $a$ 的长度、操作次数以及计算机允许的最大值。</p>
<p>第二行包含 $n$ 个整数 $a_1, a_2, \dots, a_n$ ($0 \le a_i \le h$) —— 初始数组 $a$。</p>
<p>接下来的 $m$ 行，每行包含两个整数 $b_i, c_i$ ($1 \le b_i \le n, 0 \le c_i \le 10^9$) —— Bessie 对数组执行的操作（下标 $b_i$ 增加 $c_i$）。</p>
<p>保证所有测试用例中 $n$ 和 $m$ 的总和不超过 $2 \cdot 10^5$。</p>
<h3>输出格式</h3>
<p>对于每个测试用例，输出所有操作执行完毕后的数组 $a$。</p>
<h2>样例</h2>
<p><strong>输入</strong></p>
<pre lang="text" class="notranslate"><code class="notranslate">3
3 4 5
1 2 1
1 4
2 4
3 3
2 0
5 3 1
1 1 1 1 1
1 1
1 1
2 1
4 4 1
1 0 0 0
1 1
4 4
3 3
4 4
</code></pre>
<p><strong>输出</strong></p>
<pre lang="text" class="notranslate"><code class="notranslate">3
3 4 5
1 2 1
1 4
2 4
3 3
2 0
5 3 1
1 1 1 1 1
1 1
1 1
2 1
4 4 1
1 0 0 0
1 1
4 4
3 3
4 4
</code></pre>
<blockquote>
<p>思路:正常的模拟肯定要超时，我们可以用vector&lt;pari&lt;&gt;&gt;记录当前操作的&lt;下标，增值&gt;(类似时间戳),当然如果没有超过h的话，要给数组本身增值，如果超过了呢，那么就一边出栈，一边还原之前的值。<br>
时间复杂度大概是(n+m)，因为对于每次操作，我们要么合法，让它入栈，要么不合法让它出栈，均摊下来就是m的复杂度。<br>
代码:</p>
</blockquote>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">1e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">2</span> * N, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }

<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    ll n, m, h;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;
    vll <span class="pl-smi">a</span>(n + <span class="pl-c1">1</span>, <span class="pl-c1">0</span>);
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n) cin &gt;&gt; a[i];
    vector&lt;PLL&gt;q;

    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, m)
    {
        ll k, c;
        cin &gt;&gt; k &gt;&gt; c;
        <span class="pl-k">if</span> (a[k] + c &gt; h)
        {
            <span class="pl-k">while</span>(q.<span class="pl-c1">size</span>())
            {
                <span class="pl-k">auto</span> [fi,se]=q.<span class="pl-c1">back</span>();
                q.<span class="pl-c1">pop_back</span>();
                a[fi]-=se;
            }
        }
        <span class="pl-k">else</span>
        {
            a[k] += c;
            q.<span class="pl-c1">push_back</span>({k,c});
        }
    }
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n) cout &lt;&lt; a[i] &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
    cout &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
     cin&gt;&gt;_;<span class="pl-c"><span class="pl-c">//</span>如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h1>E. The Robotic Rush</h1>
<h2>题目大意</h2>
<p>在一条无限长的数轴上，有 $n$ 个机器人和 $m$ 个尖刺。机器人和尖刺的位置给定。<br>
系统会下发 $k$ 条指令（<code class="notranslate">L</code> 或 <code class="notranslate">R</code>），所有机器人<strong>同时</strong>执行相同的移动操作。<br>
如果机器人碰到尖刺，立即死亡。求每一步操作后存活的机器人数量。</p>
<h2>解题思路</h2>
<p>这道题的关键在于利用<strong>相对运动</strong>和<strong>预处理</strong>来降低复杂度。</p>
<h3>1. 相对位移</h3>
<p>因为所有机器人动作一致，我们可以维护一个全局变量 <code class="notranslate">far</code> 表示当前的相对位移。</p>
<ul>
<li>初始 <code class="notranslate">far = 0</code>。</li>
<li>指令 <code class="notranslate">L</code>: <code class="notranslate">far--</code>。</li>
<li>指令 <code class="notranslate">R</code>: <code class="notranslate">far++</code>。<br>
机器人 $i$ 的实际位置 = $a[i] + far$。</li>
</ul>
<h3>2. 最近威胁与预处理</h3>
<p>一个机器人只会被它<strong>左边最近</strong>或<strong>右边最近</strong>的尖刺杀死。<br>
因此，我们可以预处理出每个机器人的“致死距离”：</p>
<ul>
<li><code class="notranslate">l</code>: 向左走多少步撞到左侧尖刺。</li>
<li><code class="notranslate">r</code>: 向右走多少步撞到右侧尖刺。</li>
</ul>
<p>在我的代码中，使用了<strong>二分查找</strong>（<code class="notranslate">ckl</code> 和 <code class="notranslate">ckr</code> 函数）来快速找到每个机器人左右两侧的尖刺位置。</p>
<h3>3. 桶  与 懒删除</h3>
<p>知道了每个机器人的致死距离后，我们不需要每一步都检查所有机器人。<br>
我使用了两个桶数组 <code class="notranslate">dl</code> 和 <code class="notranslate">dr</code>：</p>
<ul>
<li><code class="notranslate">dl[d]</code>: 存储所有“向左走 <code class="notranslate">d</code> 步会死”的机器人 ID。</li>
<li><code class="notranslate">dr[d]</code>: 存储所有“向右走 <code class="notranslate">d</code> 步会死”的机器人 ID。</li>
</ul>
<h3>4. 线性模拟</h3>
<p>在处理指令时，我维护了一个 <code class="notranslate">st</code>  数组。<br>
只有当 <code class="notranslate">far</code> 到达了一个<strong>之前从未到达过</strong>的位置时（说明探索了新的区域），才可能触发新的死亡。<br>
此时，根据当前是向左还是向右，去遍历对应距离的桶（<code class="notranslate">dl</code> 或 <code class="notranslate">dr</code>），将里面的机器人标记为 <code class="notranslate">dead</code> 并从总数 <code class="notranslate">now</code> 中减去。</p>
<h2>AC 代码</h2>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span> <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); cin.tie(<span class="pl-c1">0</span>); cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }

<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>
<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    ll n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    vll <span class="pl-smi">a</span>(n + <span class="pl-c1">1</span>, <span class="pl-c1">0</span>), <span class="pl-c1">b</span>(m + <span class="pl-c1">2</span>, <span class="pl-c1">0</span>);
    
    <span class="pl-c"><span class="pl-c">//</span> 读入机器人位置</span>
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n) {
        cin &gt;&gt; a[i];
    }
    <span class="pl-c"><span class="pl-c">//</span> 读入尖刺位置</span>
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, m) {
        cin &gt;&gt; b[i];
    }
    
    <span class="pl-c"><span class="pl-c">//</span> 设置哨兵，防止越界，简化二分边界判断</span>
    b[<span class="pl-c1">0</span>] = -INF, b[m + <span class="pl-c1">1</span>] = INF;
    
    <span class="pl-c"><span class="pl-c">//</span> 排序，为了后续二分查找</span>
    <span class="pl-c1">sort_range</span>(a, <span class="pl-c1">1</span>, n);
    <span class="pl-c1">sort_range</span>(b, <span class="pl-c1">1</span>, m);

    <span class="pl-c"><span class="pl-c">//</span> Lambda: 二分查找 &lt;= x 的最大尖刺 (左边最近)</span>
    <span class="pl-k">auto</span> ckl = [&amp;](ll x) {
        ll l = <span class="pl-c1">0</span>, r = m + <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (l + <span class="pl-c1">1</span> &lt; r) {
            ll mid = (l + r) &gt;&gt; <span class="pl-c1">1</span>;
            <span class="pl-k">if</span> (b[mid] &lt;= x) l = mid;
            <span class="pl-k">else</span> r = mid;
        }
        <span class="pl-k">return</span> b[l];
    };

    <span class="pl-c"><span class="pl-c">//</span> Lambda: 二分查找 &gt; x 的最小尖刺 (右边最近)</span>
    <span class="pl-c"><span class="pl-c">//</span> 注意：题意是不重合，所以找 &gt;= 或 &gt; 都可以，这里逻辑是找右侧威胁</span>
    <span class="pl-k">auto</span> ckr = [&amp;](ll x) {
        ll l = <span class="pl-c1">0</span>, r = m + <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (l + <span class="pl-c1">1</span> &lt; r) {
            ll mid = (l + r) &gt;&gt; <span class="pl-c1">1</span>;
            <span class="pl-k">if</span> (b[mid] &lt; x) l = mid;
            <span class="pl-k">else</span> r = mid;
        }
        <span class="pl-k">return</span> b[r];
    };

    <span class="pl-c"><span class="pl-c">//</span> dl[d]: 向左走 d 步会死的机器人列表</span>
    <span class="pl-c"><span class="pl-c">//</span> dr[d]: 向右走 d 步会死的机器人列表</span>
    vector&lt;vector&lt;ll&gt;&gt; <span class="pl-c1">dl</span>(k + <span class="pl-c1">5</span>), <span class="pl-c1">dr</span>(k + <span class="pl-c1">5</span>);
    
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        <span class="pl-c"><span class="pl-c">//</span> 计算致死距离</span>
        ll l = a[i] - <span class="pl-c1">ckl</span>(a[i]); <span class="pl-c"><span class="pl-c">//</span> 左距离</span>
        ll r = <span class="pl-c1">ckr</span>(a[i]) - a[i]; <span class="pl-c"><span class="pl-c">//</span> 右距离</span>
        
        <span class="pl-c"><span class="pl-c">//</span> 只有在 k 步内能撞上的才存入桶中</span>
        <span class="pl-k">if</span> (l &lt;= k) dl[l].<span class="pl-c1">push_back</span>(i);
        <span class="pl-k">if</span> (r &lt;= k) dr[r].<span class="pl-c1">push_back</span>(i);
    }

    <span class="pl-c"><span class="pl-c">//</span> offset 用于处理负数下标，st 数组记录相对位移是否访问过</span>
    <span class="pl-k">const</span> <span class="pl-k">int</span> offset = <span class="pl-c1">2e5</span> + <span class="pl-c1">5</span>;
    vector&lt;<span class="pl-k">bool</span>&gt; <span class="pl-c1">st</span>(<span class="pl-c1">4e5</span> + <span class="pl-c1">10</span>, <span class="pl-c1">false</span>);
    vector&lt;<span class="pl-k">bool</span>&gt; <span class="pl-c1">dead</span>(n + <span class="pl-c1">1</span>, <span class="pl-c1">false</span>);
    
    st[<span class="pl-c1">0</span> + offset] = <span class="pl-c1">true</span>;
    ll far = <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span> 当前相对位移</span>
    ll now = n; <span class="pl-c"><span class="pl-c">//</span> 当前存活数</span>
    
    string op;
    cin &gt;&gt; op;
    
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">0</span>, k - <span class="pl-c1">1</span>)
    {
        <span class="pl-k">char</span> s = op[i];
        <span class="pl-k">if</span> (s == <span class="pl-s"><span class="pl-pds">'</span>L<span class="pl-pds">'</span></span>)
        {
            far -= <span class="pl-c1">1</span>;
            <span class="pl-c"><span class="pl-c">//</span> 如果这个位置之前没到过（探索新区域）</span>
            <span class="pl-k">if</span> (!st[far + offset])
            {
                st[far + offset] = <span class="pl-c1">true</span>;
                ll d = <span class="pl-c1">abs</span>(far);
                <span class="pl-c"><span class="pl-c">//</span> 且距离在射程范围内</span>
                <span class="pl-k">if</span> (d &lt;= k)
                {
                    <span class="pl-c"><span class="pl-c">//</span> 结算所有“向左走 d 步死”的机器人</span>
                    <span class="pl-k">for</span> (<span class="pl-k">auto</span> id : dl[d])
                    {
                        <span class="pl-k">if</span> (!dead[id]) <span class="pl-c"><span class="pl-c">//</span> 防止重复死亡</span>
                        {
                            dead[id] = <span class="pl-c1">true</span>;
                            now--;
                        }
                    }
                }
            }
        }
        <span class="pl-k">else</span> <span class="pl-c"><span class="pl-c">//</span> s == 'R'</span>
        {
            far += <span class="pl-c1">1</span>;
            <span class="pl-k">if</span> (!st[far + offset])
            {
                st[far + offset] = <span class="pl-c1">true</span>;
                ll d = <span class="pl-c1">abs</span>(far);
                <span class="pl-k">if</span> (d &lt;= k)
                {
                    <span class="pl-c"><span class="pl-c">//</span> 结算所有“向右走 d 步死”的机器人</span>
                    <span class="pl-k">for</span> (<span class="pl-k">auto</span> id : dr[d])
                    {
                        <span class="pl-k">if</span> (!dead[id])
                        {
                            dead[id] = <span class="pl-c1">true</span>;
                            now--;
                        }
                    }
                }
            }
        }
        cout &lt;&lt; now &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
    }
    cout &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;
    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    cin &gt;&gt; _;
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h1>F. BattleCows</h1>
<p><strong>题目链接：</strong> <a href="https://codeforces.com/contest/1930/problem/F" rel="nofollow">F. BattleCows</a></p>
<h2>题目大意</h2>
<p>有 $2^n$ 头奶牛进行锦标赛（满二叉树结构）。每头奶牛初始在一个栈中。<br>
比赛规则：</p>
<ol>
<li>奇数位置栈 vs 偶数位置栈。</li>
<li>栈的“战斗力”是栈内所有元素异或和。</li>
<li>战斗力高的获胜，若相等则左边获胜。</li>
<li><strong>获胜的栈跳到失败的栈上方合并</strong>。</li>
</ol>
<p>有 $q$ 次独立查询：将第 $b$ 头奶牛的值临时改为 $c$，问最终 $b$ 头顶上有多少头奶牛。</p>
<h2>解题思路</h2>
<p>这道题如果直接模拟栈的合并过程会比较繁琐。我们需要通过观察发现规律：</p>
<ol>
<li>
<p><strong>分治结构</strong>：比赛过程本质上是一个满二叉树的归并过程。我们可以使用分治（递归）来模拟每一层的比赛。</p>
</li>
<li>
<p><strong>胜负判定</strong>：每一层比赛比较的是两个区间的异或和。我们可以使用<strong>前缀异或数组 (<code class="notranslate">pre</code>)</strong> 来 $O(1)$ 获取任意区间的原始异或和。</p>
</li>
<li>
<p><strong>单点修改的处理</strong>：<br>
查询是独立的，我们不需要真的修改数组或线段树。<br>
对于当前递归到的区间，如果包含目标奶牛 $b$，我们只需要计算该区间的异或和时，利用异或的性质：<code class="notranslate">新异或和 = 原异或和 ^ a[b] ^ c</code>。这样就可以动态获得修改后的值。</p>
</li>
<li>
<p><strong>计算头顶数量</strong>：<br>
题目问 $b$ 上面有多少牛。</p>
<ul>
<li>如果 $b$ 所在的栈 <strong>赢了</strong>：它会跳到别人头上，它头顶的数量<strong>不变</strong>。</li>
<li>如果 $b$ 所在的栈 <strong>输了</strong>：对手的栈（大小为 <code class="notranslate">sz</code>）会压在它头上，它头顶的数量 <strong>增加 <code class="notranslate">sz</code></strong>。</li>
</ul>
<p>因此，我们只需要从根节点向下递归，或者从叶子节点向上回溯。这里采用<strong>自顶向下的分治</strong>：</p>
<ul>
<li>递归找到 $b$ 所在的子区间。</li>
<li>判断当前层 $b$ 所在的半区是否输了。如果输了，答案累加对手半区的大小 (<code class="notranslate">sz</code>)。</li>
</ul>
</li>
</ol>
<h2>复杂度分析</h2>
<ul>
<li><strong>预处理</strong>：计算前缀异或和，时间复杂度为 <code class="notranslate">O(2^n)</code>。</li>
<li><strong>查询</strong>：每次查询只需要递归 <code class="notranslate">n</code> 层，每层为常数操作。单次查询复杂度为 <code class="notranslate">O(n)</code>。</li>
<li><strong>总复杂度</strong>：<code class="notranslate">O(2^n + n * q)</code>。<br>
在 <code class="notranslate">n &lt;= 18</code> 且 <code class="notranslate">q &lt;= 2*10^5</code> 的数据范围内，计算量约为 <code class="notranslate">2.6*10^5 + 3.6*10^6</code>，完全可以在 2 秒内轻松通过。</li>
</ul>
<h2>AC 代码</h2>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>

<span class="pl-c"><span class="pl-c">//</span> 通用模板部分</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span> <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); cin.tie(<span class="pl-c1">0</span>); cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    ll n, q; 
    cin &gt;&gt; n &gt;&gt; q;
    ll len = <span class="pl-c1">1</span> &lt;&lt; n; <span class="pl-c"><span class="pl-c">//</span> 总奶牛数 2^n</span>
    
    <span class="pl-c"><span class="pl-c">//</span> a: 原数组, pre: 前缀异或和数组</span>
    vll <span class="pl-smi">a</span>(len + <span class="pl-c1">1</span>, <span class="pl-c1">0</span>), <span class="pl-c1">pre</span>(len + <span class="pl-c1">2</span>, <span class="pl-c1">0</span>);
    
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, len)
    {
        cin &gt;&gt; a[i];
        <span class="pl-k">pre</span>[i] = <span class="pl-k">pre</span>[i - <span class="pl-c1">1</span>] ^ a[i];
    }
    
    <span class="pl-k">while</span>(q--)
    {
        ll b, c; 
        cin &gt;&gt; b &gt;&gt; c;
        
        <span class="pl-c"><span class="pl-c">//</span> 定义分治递归函数</span>
        <span class="pl-c"><span class="pl-c">//</span> l, r: 当前处理的区间范围</span>
        <span class="pl-k">auto</span> fz = [&amp;](<span class="pl-k">auto</span>&amp;&amp; self, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) -&gt; ll
        {
            <span class="pl-k">if</span>(l == r) <span class="pl-k">return</span> <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span> 叶子节点，没有对手，头顶数量为0</span>
            
            <span class="pl-k">int</span> mid = (l + r) &gt;&gt; <span class="pl-c1">1</span>;
            ll sz = (r - l + <span class="pl-c1">1</span>) / <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span> 半区大小（对手栈的大小）</span>
            
            <span class="pl-c"><span class="pl-c">//</span> 计算左右半区原本的异或和</span>
            ll L = <span class="pl-k">pre</span>[mid] ^ <span class="pl-k">pre</span>[l - <span class="pl-c1">1</span>];
            ll R = <span class="pl-k">pre</span>[r] ^ <span class="pl-k">pre</span>[mid];
            
            ll res = <span class="pl-c1">0</span>;
            
            <span class="pl-k">if</span>(b &lt;= mid) <span class="pl-c"><span class="pl-c">//</span> 目标奶牛在左半区</span>
            {
                <span class="pl-c"><span class="pl-c">//</span> 先递归下一层，获取底层的累积结果</span>
                res = <span class="pl-c1">self</span>(self, l, mid);
                
                <span class="pl-c"><span class="pl-c">//</span> 修正左半区的异或和：去掉原来的 a[b]，加上新的 c</span>
                L = L ^ a[b] ^ c;
                
                <span class="pl-c"><span class="pl-c">//</span> 判断胜负：左区 vs 右区</span>
                <span class="pl-c"><span class="pl-c">//</span> 题目规则：值大的赢，相等左边赢。</span>
                <span class="pl-c"><span class="pl-c">//</span> 如果 L &lt; R，说明左边输了。</span>
                <span class="pl-c"><span class="pl-c">//</span> 左边输了，右边整个栈(大小sz)会压在左边头上。</span>
                <span class="pl-k">if</span>(L &lt; R) res += sz;
            }
            <span class="pl-k">else</span> <span class="pl-c"><span class="pl-c">//</span> 目标奶牛在右半区</span>
            {
                res = <span class="pl-c1">self</span>(self, mid + <span class="pl-c1">1</span>, r);
                
                <span class="pl-c"><span class="pl-c">//</span> 修正右半区的异或和</span>
                R = R ^ a[b] ^ c;
                
                <span class="pl-c"><span class="pl-c">//</span> 如果 R &lt;= L，说明右边输了（注意平局也是左边赢，所以右边输是 &lt;=）</span>
                <span class="pl-c"><span class="pl-c">//</span> 右边输了，左边整个栈(大小sz)会压在右边头上。</span>
                <span class="pl-k">if</span>(R &lt;= L) res += sz;
            }
            
            <span class="pl-k">return</span> res;
        };
        
        <span class="pl-c"><span class="pl-c">//</span> 从整个区间开始递归</span>
        cout &lt;&lt; <span class="pl-c1">fz</span>(fz, <span class="pl-c1">1</span>, len) &lt;&lt; endl;
    }
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;
    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    cin &gt;&gt; _;
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h1>G. Mixing MEXes</h1>
<p><strong>题目链接：</strong> <a href="https://codeforces.com/contest/1930/problem/G" rel="nofollow">G. Mixing MEXes</a></p>
<h2>题目大意</h2>
<p>给你 $n$ 个数组 $a_1, a_2, \dots, a_n$。<br>
你需要执行以下操作 <strong>恰好一次</strong>：</p>
<ol>
<li>选择一个数组 $a_i$ 和其中一个元素 $x = a_{i,j}$。</li>
<li>选择另一个数组 $a_k$ ($k \neq i$)。</li>
<li>从 $a_i$ 中移除 $x$，并将 $x$ 添加到 $a_k$ 的末尾。</li>
</ol>
<p>操作的<strong>价值</strong>定义为操作后所有数组的 MEX 之和，即 $\sum_{m=1}^{n} \text{MEX}(a_m)$。<br>
求所有可能的不同操作（三元组 $(i, j, k)$ 不同）所产生的价值之<strong>和</strong>。</p>
<blockquote>
<p><strong>MEX 定义：</strong><br>
<strong>MEX(a)</strong> 定义为数组中<strong>不包含</strong>的最小非负整数。<br>
例如：<code class="notranslate">MEX([1, 2, 0, 5]) = 3</code>，<code class="notranslate">MEX([1, 2, 4, 9]) = 0</code>。</p>
</blockquote>
<h2>解题思路</h2>
<p>这就要求我们计算所有情况下的 $\sum \text{MEX}$ 的总和。直接模拟每次操作的时间复杂度太高，我们需要使用<strong>贡献法</strong>来分别计算变化的量。</p>
<h3>1. 初始状态总和</h3>
<p>首先，不管怎么操作，大部分数组的 MEX 是不会变的。<br>
假设不做任何操作，所有数组的 MEX 之和为 $S = \sum \text{MEX}(a_i)$。<br>
总共有 $L = \sum |a_i|$ 个元素可选（即总共有 $L$ 种移出元素的方式）。<br>
对于每一种移出方式，有 $n-1$ 个目标数组可以接受这个元素。<br>
所以，总的操作数量是 $L \times (n-1)$。<br>
<strong>基准答案</strong>：<code class="notranslate">ans = S * L * (n - 1)</code>。</p>
<p>接下来我们只需要计算操作对基准答案的<strong>增量（或减量）</strong>。</p>
<h3>2. 移除元素的影响 (减法贡献)</h3>
<p>当我们从 $a_i$ 中移除元素 $x$ 时，只有当 $x &amp;lt; \text{MEX}(a_i)$ 且 $x$ 在 $a_i$ 中<strong>只出现了一次</strong>时，$a_i$ 的 MEX 才会减小。</p>
<ul>
<li>减小的量：$\text{MEX}(a_i)$ 会变成 $x$。所以减少了 $\text{MEX}(a_i) - x$。</li>
<li>这种情况发生了 $n-1$ 次（因为有 $n-1$ 个目标数组 $a_k$）。</li>
<li>更新：<code class="notranslate">ans -= (MEX(a_i) - x) * (n - 1)</code>。</li>
</ul>
<h3>3. 添加元素的影响 (加法贡献)</h3>
<p>当我们把元素 $x$ 添加到 $a_k$ 中时，只有当 $x == \text{MEX}(a_k)$ 时，$a_k$ 的 MEX 才会增加。</p>
<ul>
<li>此时 $a_k$ 的 MEX 会从 $x$ 变成一个新的值 <code class="notranslate">nmex</code>（即填补了空缺后，下一个缺失的数）。</li>
<li>增加的量：<code class="notranslate">nmex - MEX(a_k)</code>。</li>
<li>这种情况发生的次数：等于<strong>所有数组中等于 $\text{MEX}(a_k)$ 的元素总个数</strong>。我们用一个全局计数器 <code class="notranslate">cnt</code> 来记录每个数字在所有数组中出现的总次数。</li>
<li>更新：<code class="notranslate">ans += (nmex - MEX(a_k)) * cnt[MEX(a_k)]</code>。</li>
</ul>
<h3>4. 算法流程</h3>
<ol>
<li>
<strong>预处理</strong>：计算所有数组的初始 MEX，计算总和 $S$，并统计所有数字的出现次数 <code class="notranslate">cnt</code>。</li>
<li>
<strong>初始化答案</strong>：<code class="notranslate">ans = S * len * (n - 1)</code>。</li>
<li>
<strong>减法修正</strong>：遍历每个数组的每个元素，如果它是“关键元素”（唯一且小于当前 MEX），从答案中减去相应的差值。</li>
<li>
<strong>加法修正</strong>：遍历每个数组，假设该数组作为接收方 $a_k$。如果此时放入的元素恰好是它的 <code class="notranslate">MEX</code>，计算新的 <code class="notranslate">MEX</code> 并加上增量。</li>
</ol>
<h2>复杂度分析</h2>
<ul>
<li><strong>预处理</strong>：需要遍历所有输入元素，时间复杂度为 <code class="notranslate">O(Σ|a_i|)</code>。</li>
<li><strong>修正计算</strong>：
<ul>
<li>减法部分遍历所有元素，复杂度为线性。</li>
<li>加法部分虽然有 <code class="notranslate">while</code> 循环寻找新的 MEX，但在排序后每个元素最多被访问常数次，均摊复杂度也是线性的。</li>
</ul>
</li>
<li><strong>总复杂度</strong>：<code class="notranslate">O(Σ|a_i| * log(max_len))</code>。
<ul>
<li>主要的时间开销在于对每个数组进行排序。</li>
<li>在题目给定的 <code class="notranslate">Σ|a_i| &lt;= 2 * 10^5</code> 数据范围内，该算法非常高效，可以通过。</li>
</ul>
</li>
</ul>
<h2>AC 代码</h2>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; 
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span> <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); cin.tie(<span class="pl-c1">0</span>); cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>

<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">1000010</span>; 
<span class="pl-k">int</span> cnt[N]; <span class="pl-c"><span class="pl-c">//</span> 用于统计全局每个数字出现的次数</span>

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    <span class="pl-k">int</span> n;
    cin &gt;&gt; n;
    
    vector&lt;vector&lt;<span class="pl-k">int</span>&gt;&gt; <span class="pl-c1">a</span>(n);
    vector&lt;<span class="pl-k">int</span>&gt; <span class="pl-c1">pmex</span>(n);
    
    ll sum = <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span> 初始所有数组 MEX 之和</span>
    ll len = <span class="pl-c1">0</span>; <span class="pl-c"><span class="pl-c">//</span> 所有元素的总个数</span>
    
    <span class="pl-c"><span class="pl-c">//</span> 1. 读入数据并预处理</span>
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">0</span>, n - <span class="pl-c1">1</span>)
    {
        <span class="pl-k">int</span> l;
        cin &gt;&gt; l;
        a[i].<span class="pl-c1">resize</span>(l);
        len += l; 
        
        <span class="pl-c1">rep</span>(j, <span class="pl-c1">0</span>, l - <span class="pl-c1">1</span>)
        {
            cin &gt;&gt; a[i][j];
            cnt[a[i][j]]++; <span class="pl-c"><span class="pl-c">//</span> 全局计数</span>
        }
        <span class="pl-c1">sort</span>(<span class="pl-c1">all</span>(a[i])); <span class="pl-c"><span class="pl-c">//</span> 排序方便求 MEX</span>
    }

    <span class="pl-c"><span class="pl-c">//</span> 2. 计算初始 MEX</span>
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">0</span>, n - <span class="pl-c1">1</span>)
    {
        <span class="pl-k">int</span> m = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> x : a[i])
        {
            <span class="pl-k">if</span> (x == m) m++;
            <span class="pl-k">else</span> <span class="pl-k">if</span> (x &gt; m) <span class="pl-k">break</span>;
        }
        pmex[i] = m;
        sum += m;
    }

    <span class="pl-c"><span class="pl-c">//</span> 3. 初始基准答案：假设 MEX 都不变</span>
    <span class="pl-c"><span class="pl-c">//</span> 总操作次数 = 总元素数 * (n-1) 个目标数组</span>
    ll ans = sum * len * (n - <span class="pl-c1">1</span>);

    <span class="pl-c"><span class="pl-c">//</span> 4. 处理移除元素导致的 MEX 减小</span>
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">0</span>, n - <span class="pl-c1">1</span>)
    {
        <span class="pl-k">int</span> sz = a[i].<span class="pl-c1">size</span>();
        <span class="pl-c1">rep</span>(j, <span class="pl-c1">0</span>, sz - <span class="pl-c1">1</span>)
        {
            <span class="pl-k">int</span> x = a[i][j];
            
            <span class="pl-c"><span class="pl-c">//</span> 检查 x 是否只出现了一次</span>
            <span class="pl-k">bool</span> check = <span class="pl-c1">true</span>;
            <span class="pl-k">if</span> (j &gt; <span class="pl-c1">0</span> &amp;&amp; a[i][j - <span class="pl-c1">1</span>] == x) check = <span class="pl-c1">false</span>;
            <span class="pl-k">if</span> (j &lt; sz - <span class="pl-c1">1</span> &amp;&amp; a[i][j + <span class="pl-c1">1</span>] == x) check = <span class="pl-c1">false</span>;

            <span class="pl-c"><span class="pl-c">//</span> 如果 x 是唯一的，且 x &lt; MEX，移除它会导致 MEX 降低为 x</span>
            <span class="pl-k">if</span> (check &amp;&amp; x &lt; pmex[i])
            {
                <span class="pl-c"><span class="pl-c">//</span> 每次操作都会少算 (pmex[i] - x)</span>
                <span class="pl-c"><span class="pl-c">//</span> 共有 n-1 个接收数组，所以减去 (n-1) 倍</span>
                ans -= (ll)(pmex[i] - x) * (n - <span class="pl-c1">1</span>);
            }
        }
    }

    <span class="pl-c"><span class="pl-c">//</span> 5. 处理添加元素导致的 MEX 增加</span>
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">0</span>, n - <span class="pl-c1">1</span>)
    {
        <span class="pl-k">int</span> tag = pmex[i]; <span class="pl-c"><span class="pl-c">//</span> 当前数组缺少的数</span>
        ll num = cnt[tag]; <span class="pl-c"><span class="pl-c">//</span> 全局有多少个这个数可以被移过来</span>
        
        <span class="pl-k">if</span> (num &gt; <span class="pl-c1">0</span>)
        {
            <span class="pl-c"><span class="pl-c">//</span> 如果把 tag 移进来，MEX 会变成多少？</span>
            <span class="pl-k">int</span> nmex = tag + <span class="pl-c1">1</span>;
            
            <span class="pl-c"><span class="pl-c">//</span> 在有序数组中找下一个缺失的数</span>
            <span class="pl-k">auto</span> it = <span class="pl-c1">upper_bound</span>(<span class="pl-c1">all</span>(a[i]), tag);
            <span class="pl-k">int</span> idx = it - a[i].<span class="pl-c1">begin</span>();
            
            <span class="pl-k">while</span> (idx &lt; a[i].<span class="pl-c1">size</span>())
            {
                <span class="pl-k">if</span> (a[i][idx] == nmex)
                {
                    nmex++;
                    <span class="pl-c"><span class="pl-c">//</span> 跳过重复的数字</span>
                    <span class="pl-k">while</span> (idx &lt; a[i].<span class="pl-c1">size</span>() &amp;&amp; a[i][idx] &lt; nmex) idx++;
                }
                <span class="pl-k">else</span>
                {
                    <span class="pl-k">break</span>; 
                }
            }

            <span class="pl-c"><span class="pl-c">//</span> 增加的贡献 = (新MEX - 旧MEX) * 来源数的个数</span>
            ans += (ll)(nmex - pmex[i]) * num;
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    <span class="pl-c"><span class="pl-c">//</span> 清空计数数组，为下一组数据做准备</span>
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">0</span>, n - <span class="pl-c1">1</span>)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> x : a[i]) cnt[x]--;
    }
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;
    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    cin &gt;&gt; _;
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h1>H. BattleCows 2 题解</h1>
<p><strong>题目链接：</strong> <a href="https://codeforces.com/contest/1930/problem/H" rel="nofollow">H. BattleCows 2</a></p>
<h2>题目大意</h2>
<p>Farmer John 举办了一场锦标赛，有 $n$ 头奶牛，技能值为 $a_i$。<br>
比赛规则：</p>
<ol>
<li>队伍最前面的两头牛进行对战，技能值高的获胜（平局时前面的赢）。</li>
<li>
<strong>赢家</strong>的技能值变为 $x+y$（两人技能之和），<strong>输家</strong>离开队伍。</li>
<li>比赛重复直到只剩一头牛。</li>
</ol>
<p><strong>作弊机制</strong>：每头牛最多可以作弊 $k$ 次。作弊时，即使它输了，也会被判为获胜，技能值同样变为 $x+y$，原本的赢家离开队伍。</p>
<p><strong>问题</strong>：对于每头奶牛 $i$，如果将它从原位置移出并插入到某个位置 $x$（其他牛相对顺序不变），使得它能利用最多 $k$ 次作弊成为最终唯一的赢家。求这样的“好位置” $x$ 有多少个？</p>
<h2>解题思路</h2>
<h3>1. 胜利条件的转化</h3>
<p>一头牛要赢得最终胜利，无论它怎么赢（靠实力还是作弊），每次胜利后它的技能值都会变成“对手技能值 + 自己当前技能值”。<br>
这意味着，如果一头牛赢到了最后，它的最终技能值一定是<strong>所有参赛牛的技能值之和</strong>。<br>
或者更准确地说，如果奶牛 $i$ 在某个位置 $x$，它前面所有牛的技能和记为 <code class="notranslate">pre</code>。</p>
<ul>
<li>如果 $a_i &amp;gt; pre$，它可以凭实力赢下前面的所有牛，技能值变为 $a_i + pre$。</li>
<li>如果 $a_i \le pre$，它必须消耗一次作弊机会才能赢下这一轮（相当于赢下这“一堆”牛），技能值也变为 $a_i + pre$。</li>
</ul>
<h3>2. 核心观察：关键对手</h3>
<p>并非每一头牛都需要我们单独判断输赢。<br>
对于奶牛 $i$ 来说，只有那些<strong>初始技能值特别大</strong>的牛才是威胁。<br>
具体的威胁判定标准是：如果某头牛 $j$ 的技能值 $a_j &amp;gt;$ (它前面所有牛的技能和)，那么这头牛 $j$ 就是一个**“强者”**。<br>
我们把这些“强者”记录在列表 <code class="notranslate">q</code> 中。对于其他普通牛，它们技能值较小，会被前面的累积和吞噬，不会成为阻碍。</p>
<h3>3. 计算“好位置”</h3>
<p>对于每头奶牛 $i$，我们想知道它插在哪个位置能赢。<br>
位置可以分为两类：</p>
<ol>
<li>
<strong>位置 $x \le$ 某个临界点</strong>：在这个位置，奶牛 $i$ 可以先吃掉前面的所有牛（可能需要作弊），然后带着累积的巨大技能值去挑战后面的牛。</li>
<li>
<strong>位置 $x &amp;gt;$ 临界点</strong>：在这个位置，前面的某些“强者”已经成长得太大了，奶牛 $i$ 即使作弊也可能不够用。</li>
</ol>
<p>我们用<strong>前缀和</strong>数组 <code class="notranslate">pre</code> 和<strong>二分查找</strong>来确定这个“临界点” <code class="notranslate">pos</code>：</p>
<ul>
<li>
<code class="notranslate">pos</code> 是奶牛 $i$ 能够凭实力（或者只作弊一次）战胜的最大的前缀位置。</li>
<li>具体来说，如果奶牛 $i$ 初始值就很大，它能吞掉的前缀就更长；否则它只能吞掉较短的前缀。</li>
</ul>
<h3>4. 贪心判定 (calc 函数)</h3>
<p>对于一个区间 $[L, R]$ 内的每一个位置，我们需要判断奶牛 $i$ 是否能赢。<br>
这转化为：奶牛 $i$ 在成长过程中，遇到列表 <code class="notranslate">q</code> 中的那些“强者”时，是否还有足够的作弊次数 $k$。</p>
<ul>
<li>遍历所有“强者” $(j, val)$。</li>
<li>如果 $j$ 在 $i$ 的前面且 $a_i$ 打不过 $j$（需要作弊），消耗 $k$。</li>
<li>如果 $j$ 在 $i$ 的后面且成长后的 $i$ 打不过 $j$，消耗 $k$。</li>
<li>如果 $k &amp;lt; 0$，说明这个位置不可行。</li>
<li>只有满足条件的区间长度才会计入答案。</li>
</ul>
<h2>复杂度分析</h2>
<ul>
<li>
<strong>预处理</strong>：计算前缀和并筛选“强者”列表 <code class="notranslate">q</code>，时间复杂度 $O(n)$。</li>
<li>
<strong>查询</strong>：对于每头牛，二分查找临界点 $O(\log n)$，然后遍历 <code class="notranslate">q</code> 列表进行检查。
<ul>
<li>虽然看起来是 $O(n \cdot |q|)$，但由于技能值呈指数级增长，“强者”的数量 $|q|$ 非常少（最多 $O(\log (\sum a_i))$，约为 60 个）。</li>
</ul>
</li>
<li>
<strong>总复杂度</strong>：$O(n \log (\text{TotalSum}))$，在 $2 \cdot 10^5$ 范围内非常快。</li>
</ul>
<h2>AC 代码</h2>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>

<span class="pl-c"><span class="pl-c">//</span> 通用模板部分</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span> <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); cin.tie(<span class="pl-c1">0</span>); cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>

<span class="pl-c"><span class="pl-c">//</span> 更新最大值函数</span>
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    ll n, k;
    cin &gt;&gt; n &gt;&gt; k;
    
    <span class="pl-c"><span class="pl-c">//</span> a: 技能值, pre: 前缀和</span>
    vll <span class="pl-smi">a</span>(n + <span class="pl-c1">1</span>, <span class="pl-c1">0</span>), <span class="pl-c1">pre</span>(n + <span class="pl-c1">1</span>, <span class="pl-c1">0</span>);
    vector&lt;PLL&gt; q; <span class="pl-c"><span class="pl-c">//</span> 存储“强者”：{下标, 需要的技能阈值}</span>
    
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        cin &gt;&gt; a[i];
        <span class="pl-k">pre</span>[i] = <span class="pl-k">pre</span>[i - <span class="pl-c1">1</span>] + a[i];
        
        <span class="pl-c"><span class="pl-c">//</span> 如果当前牛比前面所有牛的总和还大，它是一个潜在的威胁（强者）</span>
        <span class="pl-c"><span class="pl-c">//</span> 记录它，因为它可能会迫使别人消耗作弊次数</span>
        <span class="pl-k">if</span> (a[i] &gt; <span class="pl-k">pre</span>[i - <span class="pl-c1">1</span>])
        {
            q.<span class="pl-c1">push_back</span>({i, a[i] - <span class="pl-k">pre</span>[i - <span class="pl-c1">1</span>]});
        }
    }
    
    <span class="pl-c"><span class="pl-c">//</span> 逆序处理，方便后续遍历</span>
    <span class="pl-c1">reverse</span>(<span class="pl-c1">all</span>(q));
    
    <span class="pl-c"><span class="pl-c">//</span> 核心判定函数：在区间 [l, r] 内，奶牛 pos 是否有足够的作弊次数 cnt</span>
    <span class="pl-k">auto</span> calc = [&amp;](ll l, ll r, ll pos, ll cnt) -&gt; ll
    {
        <span class="pl-k">if</span> (cnt &lt; <span class="pl-c1">0</span>) <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        
        <span class="pl-c"><span class="pl-c">//</span> 遍历所有“强者”，检查是否会消耗作弊次数</span>
        <span class="pl-k">for</span> (<span class="pl-k">auto</span> p : q)
        {
            <span class="pl-k">auto</span> [x, y] = p; <span class="pl-c"><span class="pl-c">//</span> x: 强者下标, y: 阈值</span>
            <span class="pl-k">if</span> (x != pos)
            {
                <span class="pl-c"><span class="pl-c">//</span> 如果强者 x 在 pos 后面，或者 pos 打不过强者 x 的阈值 y</span>
                <span class="pl-c"><span class="pl-c">//</span> 这里的逻辑是：如果 x 是一个威胁，我们需要消耗一次作弊机会</span>
                <span class="pl-c"><span class="pl-c">//</span> (x &gt; pos) 表示 x 在 pos 后面，如果不作弊可能会输</span>
                <span class="pl-c"><span class="pl-c">//</span> (a[pos] &lt; y) 表示 pos 即使在前面，初始值太小也打不过 x</span>
                <span class="pl-k">if</span> (x &gt; pos || a[pos] &lt; y)
                    cnt--;
                
                <span class="pl-c"><span class="pl-c">//</span> 如果作弊次数不够了，说明当前的 l 位置不可行</span>
                <span class="pl-c"><span class="pl-c">//</span> 我们需要把 l 往后推，尝试缩短区间</span>
                <span class="pl-k">if</span> (cnt &lt; <span class="pl-c1">0</span>)
                    <span class="pl-c1">cmax</span>(l, x + (x &lt; pos));
            }
        }
        <span class="pl-c"><span class="pl-c">//</span> 返回有效区间的长度</span>
        <span class="pl-k">return</span> <span class="pl-c1">max</span>((ll)<span class="pl-c1">0</span>, r - l + <span class="pl-c1">1</span>);
    };

    <span class="pl-c"><span class="pl-c">//</span> 二分查找函数：找到第一个前缀和 &gt;= x 的位置</span>
    <span class="pl-c"><span class="pl-c">//</span> 用于确定奶牛 i 能凭实力（或一次作弊）吞噬到的最远边界</span>
    <span class="pl-k">auto</span> f = [&amp;](ll x) -&gt; ll
    {
        ll l = <span class="pl-c1">0</span>, r = n + <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (l + <span class="pl-c1">1</span> &lt; r)
        {
            ll mid = l + (r - l) / <span class="pl-c1">2</span>;
            <span class="pl-k">if</span> (<span class="pl-k">pre</span>[mid] &gt;= x)
                r = mid;
            <span class="pl-k">else</span>
                l = mid;
        }
        <span class="pl-k">return</span> r;
    };

    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        ll pos = <span class="pl-c1">0</span>;
        <span class="pl-c"><span class="pl-c">//</span> 分情况确定临界点 pos</span>
        <span class="pl-k">if</span> (<span class="pl-k">pre</span>[i - <span class="pl-c1">1</span>] &gt;= a[i])
        {
            <span class="pl-c"><span class="pl-c">//</span> 情况1：a[i] 较小，打不过前面的前缀和</span>
            <span class="pl-c"><span class="pl-c">//</span> 它需要消耗作弊次数才能赢下第一场</span>
            <span class="pl-c"><span class="pl-c">//</span> pos 是它能成长到的位置</span>
            pos = <span class="pl-c1">f</span>(a[i]);
        }
        <span class="pl-k">else</span>
        {
            <span class="pl-c"><span class="pl-c">//</span> 情况2：a[i] 很大，能直接吃掉前面的前缀</span>
            <span class="pl-c"><span class="pl-c">//</span> 它的技能会翻倍增长，pos 会更远</span>
            pos = <span class="pl-c1">f</span>(<span class="pl-c1">2</span> * a[i]) - <span class="pl-c1">1</span>;
        }
        
        <span class="pl-k">if</span> (pos &gt; n) pos = n;
        
        <span class="pl-c"><span class="pl-c">//</span> 计算两段区间的贡献：</span>
        <span class="pl-c"><span class="pl-c">//</span> 1. [1, pos]: 在这个范围内，它可能只需要 k 次作弊</span>
        <span class="pl-c"><span class="pl-c">//</span> 2. [pos+1, n]: 在这个范围内，它可能需要额外的一次作弊（因为初始就落后了），所以是 k-1</span>
        ll ans = <span class="pl-c1">calc</span>(<span class="pl-c1">1</span>, pos, i, k) + <span class="pl-c1">calc</span>(pos + <span class="pl-c1">1</span>, n, i, k - <span class="pl-c1">1</span>);
        cout &lt;&lt; ans &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
    }
    cout &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;
    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    cin &gt;&gt; _;
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://zhezhi198.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","zhezhi198/zhezhi198.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
