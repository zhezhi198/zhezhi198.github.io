<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="[比赛链接](https://atcoder.jp/contests/abc437/tasks)
##  C Reindeer and Sleigh 2

#### 问题陈述

有 $N$ 头驯鹿和一个雪橇。">
<meta property="og:title" content="abc_437 部分题解">
<meta property="og:description" content="[比赛链接](https://atcoder.jp/contests/abc437/tasks)
##  C Reindeer and Sleigh 2

#### 问题陈述

有 $N$ 头驯鹿和一个雪橇。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhezhi198.github.io/post/abc_437%20-bu-fen-ti-jie.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>abc_437 部分题解</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">abc_437 部分题解</h1>
<div class="title-right">
    <a href="https://zhezhi198.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/zhezhi198/zhezhi198.github.io/issues/14" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p><a href="https://atcoder.jp/contests/abc437/tasks" rel="nofollow">比赛链接</a></p>
<h2>C Reindeer and Sleigh 2</h2>
<h4>问题陈述</h4>
<p>有 $N$ 头驯鹿和一个雪橇。这只 $i$ 只驯鹿的重量是 $W _ i$ ，力量是 $P _ i$ 。</p>
<p>每只驯鹿可以选择 "拉雪橇 "或 "坐雪橇"。这里，拉雪橇的驯鹿的总力量必须大于或等于坐雪橇的驯鹿的总重量。最多可以有多少只驯鹿坐上雪橇？</p>
<p>给你 $T$ 个测试案例。请逐一解答。</p>
<h4>限制因素</h4>
<ul>
<li>$1\leq T\leq 10^5$</li>
<li>$1\leq N\leq 3\times 10^5$</li>
<li>$1\leq W _ i,P _ i\leq 10^9$</li>
<li>所有输入值均为整数。</li>
<li>一个输入文件中 $N$ 的总和最多为 $3\times 10^5$ 。</li>
<li>
<h4>输入</h4>
</li>
</ul>
<p>输入内容由标准输入法提供，格式如下</p>
<p>$T$<br>
$\mathrm{case}_1$<br>
$\mathrm{case}_2$<br>
$\vdots$<br>
$\mathrm{case}_T$</p>
<p>每个测试用例的格式如下：</p>
<p>$N$<br>
$W_1$ $P_1$<br>
$W_2$ $P_2$<br>
$\vdots$<br>
$W_N$ $P_N$</p>
<blockquote>
<p>思路:对于每个人可以选择加入重量，也可以选择贡献拉力，因为这两个只能选一个那么，我们假设所有人都贡献拉力，我们可以得出一个等式，选着加入重量的人的重量和&lt;=所有人的拉力-选着加入重量的人的拉力，移项之后等价于每个人选择上车的代价是自己的拉力和重量之和，于是我们可以按照自己的拉力和重量之和从小达到排序，我们最后不能超过全部拉力的大小即可。</p>
</blockquote>
<p>AC代码：</p>
<pre class="notranslate"><code class="notranslate">cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair&lt;int, int&gt; PII;
typedef pair&lt;ll, ll&gt; PLL;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;double&gt; vd;
typedef vector&lt;PII&gt; vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define debug(...) cout &lt;&lt; "[debug] " #__VA_ARGS__ " = " &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#define out(x) cout &lt;&lt; ((x) ? "YES" : "NO") &lt;&lt; endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p &lt;&lt; 1
#define rc p &lt;&lt; 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) &amp; (-x))
#define rep(i, x, n) for (ll i = x; i &lt;= n; i++)
#define dep(i, x, n) for (ll i = x; i &gt;= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 3e5 + 10, M = 2 * N, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template &lt;typename T&gt;
bool cmin(T &amp;a, const T &amp;b) { return b &lt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
bool cmax(T &amp;a, const T &amp;b) { return b &gt; a ? a = b, 1 : 0; }
template &lt;typename T&gt;
void sort_range(vector&lt;T&gt; &amp;v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
template &lt;typename T&gt;
struct BIT1
{
    int n;
    vector&lt;T&gt; tr;
    BIT1(int n) : n(n), tr(n + 1) {}
    void add(int x, T v)
    {
        for (; x &lt;= n; x += x &amp; -x)
            tr[x] += v;
    }
    T sum(int x)
    {
        T r = 0;
        for (; x; x -= x &amp; -x)
            r += tr[x];
        return r;
    }
    T range(int l, int r) { return sum(r) - sum(l - 1); }
};
template &lt;typename T&gt;
struct BIT2
{
    int n, m;
    vector&lt;vector&lt;T&gt;&gt; t1, t2, t3, t4;
    BIT2(int n_ = 0, int m_ = 0) { init(n_, m_); }
    void init(int n_, int m_)
    {
        n = n_;
        m = m_;
        t1.assign(n + 1, vector&lt;T&gt;(m + 1, T{}));
        t2.assign(n + 1, vector&lt;T&gt;(m + 1, T{}));
        t3.assign(n + 1, vector&lt;T&gt;(m + 1, T{}));
        t4.assign(n + 1, vector&lt;T&gt;(m + 1, T{}));
    }
    void _add(int x, int y, const T &amp;v)
    {
        for (int i = x; i &lt;= n; i += i &amp; -i)
            for (int j = y; j &lt;= m; j += j &amp; -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    void rangeAdd(int x1, int y1, int x2, int y2, const T &amp;v)
    {
        _add(x1, y1, v);
        _add(x1, y2 + 1, -v);
        _add(x2 + 1, y1, -v);
        _add(x2 + 1, y2 + 1, v);
    }
    T prefixSum(int x, int y)
    {
        T r{};
        for (int i = x; i &gt; 0; i -= i &amp; -i)
            for (int j = y; j &gt; 0; j -= j &amp; -j)
                r += t1[i][j] * (x + 1) * (y + 1) - t2[i][j] * (y + 1) - t3[i][j] * (x + 1) + t4[i][j];
        return r;
    }
    T rangeSum(int x1, int y1, int x2, int y2)
    {
        if (x1 &gt; x2 || y1 &gt; y2)
            return T{};
        return prefixSum(x2, y2) - prefixSum(x1 - 1, y2) - prefixSum(x2, y1 - 1) + prefixSum(x1 - 1, y1 - 1);
    }
};
struct Random
{
    mt19937_64 rng;
    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
    ll rand_ll(ll l, ll r) { return uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    int rand_int(int l, int r) { return uniform_int_distribution&lt;int&gt;(l, r)(rng); }
    double rand_db(double l, double r) { return uniform_real_distribution&lt;double&gt;(l, r)(rng); }
    bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
    template &lt;typename T&gt;
    void shuffle(vector&lt;T&gt; &amp;v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
    ll res = 1 % p;
    a %= p;
    while (b)
    {
        if (b &amp; 1)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}
/*

*/
void solve()
{
    ll n;
    cin &gt;&gt; n;
    vector&lt;PLL&gt; s(n + 1, {0, 0});
    ll tot = 0;
    rep(i, 1, n) cin &gt;&gt; s[i].fi &gt;&gt; s[i].se, tot += s[i].se;
    sort(s.begin() + 1, s.end(), [&amp;](const auto &amp;a, const auto &amp;b)
         { return a.fi + a.se &lt; b.fi + b.se; });
    ll now = 0, ans = 0;
    rep(i, 1, n)
    {
        ll x = s[i].fi + s[i].se;
        if (now + x &lt;= tot)
        {
            ans++;
            now += x;
        }
        else
        {
            break;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}

int main()
{
    IOS;

    int _ = 1;
    cin &gt;&gt; _; // 如果是多组数据
    while (_--)
    {
        solve();
    }
    return 0;
}
</code></pre>
<h2>D Sum of Differences</h2>
<h4>问题陈述</h4>
<p>给你一个长度为 $N$ 的正整数序列 $A = (A _ 1, A _ 2, \dots, A _ N)$ 和一个长度为 $M$ 的正整数序列 $B = (B _ 1, B _ 2, \dots, B _ M)$ 。</p>
<p>求 $\displaystyle \sum _ {i=1}^{N} \sum _ {j=1}^{M} |A _ i - B _ j|$ 的值，模为 $998244353$ 。</p>
<h4>限制因素</h4>
<ul>
<li>$1 \leq N,M \leq 3 \times 10^5$</li>
<li>$1 \leq A _ i, B _ j &amp;lt; 998244353$</li>
<li>所有输入值均为整数。</li>
<li>
<h4>输出</h4>
</li>
</ul>
<p>单行输出答案。</p>
<h4>输入</h4>
<p>输入内容由标准输入法提供，格式如下</p>
<p>$N$ $M$<br>
$A_1$ $A_2$ $\cdots$ $A_N$<br>
$B_1$ $B_2$ $\cdots$ $B_M$</p>
<blockquote>
<p>思路：看到这个题目暴力肯定是不可取的，[Ai-Bi]的结果都有绝对值，那么自然而然聪明一点的想法是拆开绝对值符号，算当前的Ai对答案的贡献，以及在当前Ai下Bi的贡献是多少，我们不难发现要想去绝对值改变符号的话，要求B数组中有大于当前Ai的数存在，在这个数之前的所有B数组都是负贡献，在此之后的B数组都是正贡献，那么A数组恰好相反，由于B数组的连续性，我们可以维护B数组的前缀和来优化算B数组的贡献，知道这些之后就是二分找出B数组大于当前A的索引，然后注意合理取模就好。</p>
</blockquote>
<p>AC代码：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">1e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">2</span> * N, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT1</span>
{
    <span class="pl-k">int</span> n;
    vector&lt;T&gt; tr;
    <span class="pl-en">BIT1</span>(<span class="pl-k">int</span> n) : n(n), tr(n + <span class="pl-c1">1</span>) {}
    <span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> x, T v)
    {
        <span class="pl-k">for</span> (; x &lt;= n; x += x &amp; -x)
            tr[x] += v;
    }
    T <span class="pl-en">sum</span>(<span class="pl-k">int</span> x)
    {
        T r = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (; x; x -= x &amp; -x)
            r += tr[x];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">range</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> <span class="pl-c1">sum</span>(r) - <span class="pl-c1">sum</span>(l - <span class="pl-c1">1</span>); }
};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT2</span>
{
    <span class="pl-k">int</span> n, m;
    vector&lt;vector&lt;T&gt;&gt; t1, t2, t3, t4;
    <span class="pl-en">BIT2</span>(<span class="pl-k">int</span> n_ = <span class="pl-c1">0</span>, <span class="pl-k">int</span> m_ = <span class="pl-c1">0</span>) { <span class="pl-c1">init</span>(n_, m_); }
    <span class="pl-k">void</span> <span class="pl-en">init</span>(<span class="pl-k">int</span> n_, <span class="pl-k">int</span> m_)
    {
        n = n_;
        m = m_;
        t1.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t2.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t3.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t4.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
    }
    <span class="pl-k">void</span> <span class="pl-en">_add</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &lt;= n; i += i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &lt;= m; j += j &amp; -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    <span class="pl-k">void</span> <span class="pl-en">rangeAdd</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-c1">_add</span>(x1, y1, v);
        <span class="pl-c1">_add</span>(x1, y2 + <span class="pl-c1">1</span>, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y1, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y2 + <span class="pl-c1">1</span>, v);
    }
    T <span class="pl-en">prefixSum</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y)
    {
        T r{};
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &gt; <span class="pl-c1">0</span>; i -= i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &gt; <span class="pl-c1">0</span>; j -= j &amp; -j)
                r += t1[i][j] * (x + <span class="pl-c1">1</span>) * (y + <span class="pl-c1">1</span>) - t2[i][j] * (y + <span class="pl-c1">1</span>) - t3[i][j] * (x + <span class="pl-c1">1</span>) + t4[i][j];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">rangeSum</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2)
    {
        <span class="pl-k">if</span> (x1 &gt; x2 || y1 &gt; y2)
            <span class="pl-k">return</span> T{};
        <span class="pl-k">return</span> <span class="pl-c1">prefixSum</span>(x2, y2) - <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y2) - <span class="pl-c1">prefixSum</span>(x2, y1 - <span class="pl-c1">1</span>) + <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y1 - <span class="pl-c1">1</span>);
    }
};
<span class="pl-k">struct</span> <span class="pl-en">Random</span>
{
    mt19937_64 rng;
    <span class="pl-en">Random</span>() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); }
    ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); }
    <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); }
    <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); }
    <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
    <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); }
};
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p)
{
    ll res = <span class="pl-c1">1</span> % p;
    a %= p;
    <span class="pl-k">while</span> (b)
    {
        <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> res;
}
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    ll n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vll <span class="pl-smi">a</span>(n + <span class="pl-c1">1</span>, <span class="pl-c1">0</span>), <span class="pl-c1">b</span>(m + <span class="pl-c1">1</span>, <span class="pl-c1">0</span>);
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n) cin &gt;&gt; a[i];
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, m) cin &gt;&gt; b[i];
    map&lt;ll, ll&gt; w;
    <span class="pl-c1">sort_range</span>(a, <span class="pl-c1">1</span>, n);
    <span class="pl-c1">sort_range</span>(b, <span class="pl-c1">1</span>, m);
    vll <span class="pl-smi">preb</span>(m + <span class="pl-c1">1</span>, <span class="pl-c1">0</span>);
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, m)
    {
        preb[i] = preb[i - <span class="pl-c1">1</span>] + b[i];
    }
    ll ans = <span class="pl-c1">0</span>;
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        ll x = a[i];
        <span class="pl-k">auto</span> it = <span class="pl-c1">upper_bound</span>(b.<span class="pl-c1">begin</span>() + <span class="pl-c1">1</span>, b.<span class="pl-c1">end</span>(), x);
        <span class="pl-k">if</span> (it != b.<span class="pl-c1">end</span>())
        {
            ll d = it - b.<span class="pl-c1">begin</span>() - <span class="pl-c1">1</span>;
            ans = (ans + (x % Md3) * (((<span class="pl-c1">2</span> * d - m) % Md3 + Md3) % Md3) % Md3);
            ans = (ans - preb[d] % Md3 + Md3) % Md3;
            ans = (ans + (preb[m] - preb[d]) % Md3 + Md3) % Md3;
        }
        <span class="pl-k">else</span>
        {
            ans = (ans + (m * x) % Md3 + Md3) % Md3;
            ans = (ans - preb[m] % Md3 + Md3) % Md3;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    <span class="pl-c"><span class="pl-c">//</span> cin&gt;&gt;_;//如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>后续再补充一个手写二分的代码，容器的二分还是没那么习惯。</p>
<h2>E Sort Arrays</h2>
<h4>问题陈述</h4>
<p>有 $N+1$ 个序列 $A _ 0, A _ 1, \ldots, A _ {N}$ 。 $A _ i$ 的定义如下：</p>
<ul>
<li>
$A _ 0$ 是空序列。</li>
<li>
$A _ i\ (1\leq i\leq N)$ 是在序列 $A _ {x _ i}\ (0\leq x _ i\lt i)$ 的末尾追加整数 $y _ i$ 得到的序列。</li>
</ul>
<p>找出满足以下条件的 $(1,2,\ldots,N)$ 的排列 $P=(P _ 1, P _ 2,\ldots,P _ N)$ ：</p>
<ul>
<li>就 $i = 1,2,\ldots,N-1$ 而言，以下条件之一成立：
<ul>
<li>
$A _ {P _ i}$ 在词序上小于 $A _ {P _ {i+1}}$ 。</li>
<li>
$A _ {P _ i}= A _ {P _ {i+1}}$ 和 $P _ i\lt P _ {i+1}$ 。</li>
</ul>
</li>
</ul>
<p>换句话说，当 $A _ 1,A _ 2,\ldots,A _ N$ 按词典顺序排列时（当有多个相等的序列时，先排列指数小的序列）， $P$ 是出现在该排列中的指数序列。</p>
<p>什么是序列的词典顺序？</p>
<p>如果以下两个条件之一成立，那么序列 $S = (S _ 1,S _ 2,\ldots,S _ {|S|})$ 在词法上**小于序列 $T = (T _ 1,T _ 2,\ldots,T _ {|T|})$ 。这里， $|S|$ 和 $|T|$ 分别表示 $S$ 和 $T$ 的长度。</p>
<ol>
<li>
$|S| \lt |T|$ 和 $(S _ 1,S _ 2,\ldots,S _ {|S|}) = (T _ 1,T _ 2,\ldots,T _ {|S|})$ 。</li>
<li>存在一个整数 $1 \leq i \leq \min\lbrace |S|, |T| \rbrace$ ，使得下面两个条件都成立：
<ul>
<li>$(S _ 1,S _ 2,\ldots,S _ {i-1}) = (T _ 1,T _ 2,\ldots,T _ {i-1})$</li>
<li>
$S _ i$ 在数值上小于 $T _ i$ 。</li>
<li>
<h4>限制因素</h4>
</li>
</ul>
</li>
</ol>
<ul>
<li>$1\leq N\leq 3\times 10^5$</li>
<li>$0\leq x _ i\lt i$</li>
<li>$1\leq y _ i\leq 10^9$</li>
<li>所有输入值均为整数。</li>
<li>
<h4>输入</h4>
</li>
</ul>
<p>输入内容由标准输入法提供，格式如下</p>
<p>$N$<br>
$x_1$ $y_1$<br>
$x_2$ $y_2$<br>
$\vdots$<br>
$x_N$ $y_N$</p>
<h3><strong>题解：Sort Arrays (AtCoder E)</strong></h3>
<hr>
<h4><strong>1. 题目大意</strong></h4>
<p>给定 $N$ 个序列的生成规则：$A_0$ 为空序列，对于 $1 \le i \le N$，$A_i$ 是在序列 $A_{x_i}$（$x_i &lt; i$）的末尾追加一个整数 $y_i$ 得到的。<br>
要求将 $A_1, A_2, \dots, A_N$ 按<strong>字典序</strong>排序。如果两个序列完全相等，则编号较小的排在前面。</p>
<hr>
<h4><strong>2. 模型转化：树与字典树 (Trie)</strong></h4>
<p>由于 $A_i$ 是由 $A_{x_i}$ 派生而来的，这天然构成了一棵以 $0$ 为根节点的树：</p>
<ul>
<li>
<strong>节点与边</strong>：每个索引 $i$ 代表一个节点。父节点 $x_i$ 到子节点 $i$ 的边权为 $y_i$。</li>
<li>
<strong>序列本质</strong>：序列 $A_i$ 就是从根节点 $0$ 到节点 $i$ 路径上所有边权的有序集合。</li>
<li>
<strong>排序目标</strong>：对树上的所有节点（除 $0$ 外）进行一次符合字典序规则的遍历。</li>
</ul>
<hr>
<h4><strong>3. 核心规则与难点</strong></h4>
<ul>
<li>
<strong>前缀规则</strong>：若序列 $S$ 是 $T$ 的前缀，则 $S &amp;lt; T$。在树上表现为：<strong>父节点必须先于子节点输出</strong>。</li>
<li>
<strong>数值规则</strong>：字典序比较时，数值 $y$ 越小的分支，优先级越高。</li>
<li>
<strong>编号规则</strong>：如果多个节点生成的路径（序列）完全相同，则按节点的索引 $i$ 从小到大排序。</li>
</ul>
<p><strong>难点</strong>：当多个节点对应相同的序列时，它们在字典序上是“平级”的。如何将这些节点“合并”处理，并同时满足编号排序和后续分支的字典序比较？</p>
<hr>
<h4><strong>4. 算法设计：层级合并 DFS</strong></h4>
<p>我们采用一种“按集合递归”的 DFS 策略，模拟在隐式字典树上的搜索过程。</p>
<p><strong>DFS 函数定义</strong>：<br>
<code class="notranslate">void dfs(vector&lt;int&gt; &amp;q)</code>：其中 $q$ 存储的是当前所代表<strong>序列完全相等</strong>的节点编号集合。</p>
<p><strong>执行步骤</strong>：</p>
<ol>
<li>
<strong>排序与输出</strong>：<br>
对集合 $q$ 按编号从小到大排序并依次输出。由于 $q$ 中节点代表的是当前前缀相同的最短序列，这完美解决了“前缀规则”和“编号规则”。</li>
<li>
<strong>收集子节点</strong>：<br>
遍历 $q$ 中所有节点在链式前向星中的出边，收集所有一阶子节点，存入 <code class="notranslate">vector&lt;pair&lt;int, int&gt;&gt; ch</code>，格式为 <code class="notranslate">{权值 y, 编号 id}</code>。</li>
<li>
<strong>双指针分组（核心）</strong>：<br>
对 <code class="notranslate">ch</code> 按权值 $y$ 排序。利用双指针逻辑 <code class="notranslate">for(i=0, j=0; ...; i=j)</code>：
<ul>
<li>
<strong>权值 $y$ 不同</strong>：代表不同的字典序分支，按 $y$ 从小到大的顺序处理。</li>
<li>
<strong>权值 $y$ 相同</strong>：代表这些子节点在追加了相同的 $y$ 后，序列依然相等。将这些 $y$ 相同的编号提取到新的 <code class="notranslate">vector&lt;int&gt; nxt</code> 中。</li>
</ul>
</li>
<li>
<strong>递归向下</strong>：<br>
对每个 <code class="notranslate">nxt</code> 集合调用 <code class="notranslate">dfs(nxt)</code>，继续处理下一位的字典序。</li>
</ol>
<hr>
<h4><strong>5. 复杂度分析</strong></h4>
<ul>
<li>
<strong>时间复杂度</strong>：$O(N \log N)$。<br>
每个节点和每条边在全过程中只进入 $q$ 和 $ch$ 一次。主要的复杂度开销在于排序。全过程排序的摊还复杂度为 $O(N \log N)$。</li>
<li>
<strong>空间复杂度</strong>：$O(N)$。<br>
主要为链式前向星的存储开销和递归过程中临时 <code class="notranslate">vector</code> 的空间占用。</li>
</ul>
<hr>
<h4><strong>6. 总结</strong></h4>
<p>本题巧妙地将字典序排序转化为树形结构上的搜索。通过“集合传递”代替“单节点传递”，解决了序列相等时的状态合并问题，配合双指针分组逻辑，优雅地实现了对 Trie 树的隐式遍历。<br>
大概就是这样，借助了一些大模型，主要是这个dfs的解释我解释的总是好绕。<br>
另外我把我最原始的想法的代码给在后面。<br>
AC代码：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">3e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">2</span> * N, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT1</span>
{
    <span class="pl-k">int</span> n;
    vector&lt;T&gt; tr;
    <span class="pl-en">BIT1</span>(<span class="pl-k">int</span> n) : n(n), tr(n + <span class="pl-c1">1</span>) {}
    <span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> x, T v)
    {
        <span class="pl-k">for</span> (; x &lt;= n; x += x &amp; -x)
            tr[x] += v;
    }
    T <span class="pl-en">sum</span>(<span class="pl-k">int</span> x)
    {
        T r = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (; x; x -= x &amp; -x)
            r += tr[x];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">range</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> <span class="pl-c1">sum</span>(r) - <span class="pl-c1">sum</span>(l - <span class="pl-c1">1</span>); }
};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT2</span>
{
    <span class="pl-k">int</span> n, m;
    vector&lt;vector&lt;T&gt;&gt; t1, t2, t3, t4;
    <span class="pl-en">BIT2</span>(<span class="pl-k">int</span> n_ = <span class="pl-c1">0</span>, <span class="pl-k">int</span> m_ = <span class="pl-c1">0</span>) { <span class="pl-c1">init</span>(n_, m_); }
    <span class="pl-k">void</span> <span class="pl-en">init</span>(<span class="pl-k">int</span> n_, <span class="pl-k">int</span> m_)
    {
        n = n_;
        m = m_;
        t1.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t2.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t3.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t4.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
    }
    <span class="pl-k">void</span> <span class="pl-en">_add</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &lt;= n; i += i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &lt;= m; j += j &amp; -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    <span class="pl-k">void</span> <span class="pl-en">rangeAdd</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-c1">_add</span>(x1, y1, v);
        <span class="pl-c1">_add</span>(x1, y2 + <span class="pl-c1">1</span>, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y1, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y2 + <span class="pl-c1">1</span>, v);
    }
    T <span class="pl-en">prefixSum</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y)
    {
        T r{};
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &gt; <span class="pl-c1">0</span>; i -= i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &gt; <span class="pl-c1">0</span>; j -= j &amp; -j)
                r += t1[i][j] * (x + <span class="pl-c1">1</span>) * (y + <span class="pl-c1">1</span>) - t2[i][j] * (y + <span class="pl-c1">1</span>) - t3[i][j] * (x + <span class="pl-c1">1</span>) + t4[i][j];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">rangeSum</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2)
    {
        <span class="pl-k">if</span> (x1 &gt; x2 || y1 &gt; y2)
            <span class="pl-k">return</span> T{};
        <span class="pl-k">return</span> <span class="pl-c1">prefixSum</span>(x2, y2) - <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y2) - <span class="pl-c1">prefixSum</span>(x2, y1 - <span class="pl-c1">1</span>) + <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y1 - <span class="pl-c1">1</span>);
    }
};
<span class="pl-k">struct</span> <span class="pl-en">Random</span>
{
    mt19937_64 rng;
    <span class="pl-en">Random</span>() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); }
    ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); }
    <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); }
    <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); }
    <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
    <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); }
};
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p)
{
    ll res = <span class="pl-c1">1</span> % p;
    a %= p;
    <span class="pl-k">while</span> (b)
    {
        <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> res;
}
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>
<span class="pl-k">int</span> n;
<span class="pl-k">int</span> h[N], e[M], ne[M], w[M], idx;
<span class="pl-c"><span class="pl-c">//</span> int fa[N];</span>
<span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> a, <span class="pl-k">int</span> b, <span class="pl-k">int</span> c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}

<span class="pl-k">void</span> <span class="pl-en">dfs</span>(vector&lt;<span class="pl-k">int</span>&gt; &amp;q)
{
    <span class="pl-k">if</span> (q.<span class="pl-c1">empty</span>())
        <span class="pl-k">return</span>;
    <span class="pl-c1">sort</span>(<span class="pl-c1">all</span>(q));
    <span class="pl-k">for</span> (<span class="pl-k">auto</span> x : q)
        <span class="pl-k">if</span> (x)
            cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
    vector&lt;PII&gt; ch; <span class="pl-c"><span class="pl-c">//</span>{权值，编号};</span>
    <span class="pl-k">for</span> (<span class="pl-k">auto</span> u : q)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = h[u]; ~i; i = ne[i])
        {
            <span class="pl-k">int</span> j = e[i];
            ch.<span class="pl-c1">push_back</span>({w[i], j});
        }
    }
    <span class="pl-c1">sort</span>(<span class="pl-c1">all</span>(ch));
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>, j = <span class="pl-c1">0</span>; i &lt; ch.<span class="pl-c1">size</span>(); i = j)
    {
        <span class="pl-k">while</span> (j &lt; ch.<span class="pl-c1">size</span>() &amp;&amp; ch[j].<span class="pl-smi">fi</span> == ch[i].<span class="pl-smi">fi</span>)
            j++;
        vector&lt;<span class="pl-k">int</span>&gt; nxt;
        <span class="pl-c1">rep</span>(k, i, j - <span class="pl-c1">1</span>) nxt.<span class="pl-c1">push_back</span>(ch[k].<span class="pl-smi">se</span>);
        <span class="pl-c1">dfs</span>(nxt);
    }
}

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    <span class="pl-c1">mem</span>(h, -<span class="pl-c1">1</span>);
    cin &gt;&gt; n;
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        <span class="pl-k">int</span> x, y;
        cin &gt;&gt; x &gt;&gt; y;
        <span class="pl-c1">add</span>(x, i, y);
    }
    vector&lt;<span class="pl-k">int</span>&gt; root = {<span class="pl-c1">0</span>};
    <span class="pl-c1">dfs</span>(root);
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    <span class="pl-c"><span class="pl-c">//</span> cin&gt;&gt;_;//如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>最初MLE的代码：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">3e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">2</span> * N, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT1</span>
{
    <span class="pl-k">int</span> n;
    vector&lt;T&gt; tr;
    <span class="pl-en">BIT1</span>(<span class="pl-k">int</span> n) : n(n), tr(n + <span class="pl-c1">1</span>) {}
    <span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> x, T v)
    {
        <span class="pl-k">for</span> (; x &lt;= n; x += x &amp; -x)
            tr[x] += v;
    }
    T <span class="pl-en">sum</span>(<span class="pl-k">int</span> x)
    {
        T r = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (; x; x -= x &amp; -x)
            r += tr[x];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">range</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> <span class="pl-c1">sum</span>(r) - <span class="pl-c1">sum</span>(l - <span class="pl-c1">1</span>); }
};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT2</span>
{
    <span class="pl-k">int</span> n, m;
    vector&lt;vector&lt;T&gt;&gt; t1, t2, t3, t4;
    <span class="pl-en">BIT2</span>(<span class="pl-k">int</span> n_ = <span class="pl-c1">0</span>, <span class="pl-k">int</span> m_ = <span class="pl-c1">0</span>) { <span class="pl-c1">init</span>(n_, m_); }
    <span class="pl-k">void</span> <span class="pl-en">init</span>(<span class="pl-k">int</span> n_, <span class="pl-k">int</span> m_)
    {
        n = n_;
        m = m_;
        t1.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t2.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t3.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t4.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
    }
    <span class="pl-k">void</span> <span class="pl-en">_add</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &lt;= n; i += i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &lt;= m; j += j &amp; -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    <span class="pl-k">void</span> <span class="pl-en">rangeAdd</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-c1">_add</span>(x1, y1, v);
        <span class="pl-c1">_add</span>(x1, y2 + <span class="pl-c1">1</span>, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y1, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y2 + <span class="pl-c1">1</span>, v);
    }
    T <span class="pl-en">prefixSum</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y)
    {
        T r{};
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &gt; <span class="pl-c1">0</span>; i -= i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &gt; <span class="pl-c1">0</span>; j -= j &amp; -j)
                r += t1[i][j] * (x + <span class="pl-c1">1</span>) * (y + <span class="pl-c1">1</span>) - t2[i][j] * (y + <span class="pl-c1">1</span>) - t3[i][j] * (x + <span class="pl-c1">1</span>) + t4[i][j];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">rangeSum</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2)
    {
        <span class="pl-k">if</span> (x1 &gt; x2 || y1 &gt; y2)
            <span class="pl-k">return</span> T{};
        <span class="pl-k">return</span> <span class="pl-c1">prefixSum</span>(x2, y2) - <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y2) - <span class="pl-c1">prefixSum</span>(x2, y1 - <span class="pl-c1">1</span>) + <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y1 - <span class="pl-c1">1</span>);
    }
};
<span class="pl-k">struct</span> <span class="pl-en">Random</span>
{
    mt19937_64 rng;
    <span class="pl-en">Random</span>() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); }
    ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); }
    <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); }
    <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); }
    <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
    <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); }
};
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p)
{
    ll res = <span class="pl-c1">1</span> % p;
    a %= p;
    <span class="pl-k">while</span> (b)
    {
        <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> res;
}
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>
<span class="pl-k">int</span> n;
<span class="pl-k">int</span> h[N], e[M], ne[M], w[M], idx;
<span class="pl-k">int</span> fa[N];
<span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> a, <span class="pl-k">int</span> b, <span class="pl-k">int</span> c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    cin &gt;&gt; n;
    <span class="pl-c1">mem</span>(h, -<span class="pl-c1">1</span>);
    map&lt;<span class="pl-k">int</span>, vector&lt;<span class="pl-k">int</span>&gt;&gt; id;
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        <span class="pl-k">int</span> x, y;
        cin &gt;&gt; x &gt;&gt; y;
        fa[i] = x;
        <span class="pl-c"><span class="pl-c">//</span> add(x, i, y);</span>
        <span class="pl-c"><span class="pl-c">//</span> add(i, x, y);</span>
        id[i] = id[fa[i]];
        id[i].<span class="pl-c1">push_back</span>(y);
    }
    map&lt;vector&lt;<span class="pl-k">int</span>&gt;, vector&lt;<span class="pl-k">int</span>&gt;&gt; mp;
    <span class="pl-k">for</span> (<span class="pl-k">auto</span> [id, tmp] : id)
    {
        mp[tmp].<span class="pl-c1">push_back</span>(id);
    }
    <span class="pl-k">for</span> (<span class="pl-k">auto</span> [tmp, id] : mp)
    {
        <span class="pl-k">for</span> (<span class="pl-k">auto</span> &amp;x : id)
            <span class="pl-k">if</span> (x != <span class="pl-c1">0</span>)
                cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
    }
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    <span class="pl-c"><span class="pl-c">//</span> cin&gt;&gt;_;//如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>这份代码有12个测试点MLE了，其实想法感觉没问题，只是dfs的复杂度我不是很会分析，一开始就没觉得边dfs边排序合并这样的复杂度是可以过的。</p>
<p>后续还有两个题目，基于目前水平和期末备考，F是一个线段树的题目，如果要写，要花大量的时间调试，再加上线段树不是很熟悉，如果要写要花大量的时间，但是收获的也许只是对线段树的维护更加熟练一些，并没有太多的启发的思考，就寒假的时候再把这篇题解补充完整。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://zhezhi198.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","zhezhi198/zhezhi198.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
