<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## 数列分块入门1

<img width='1263' height='1329' alt='Image' src='https://github.com/user-attachments/assets/ba9b3ade-2373-493e-a2a8-c0d527fd1700' />

>第一题是y总的板子，但是y总的分块就讲了这个基础题目，我觉得还是太浅了，后来讲的就是链表分块，但是后来我去洛谷交了一个数据大一点点的题目，发现会卡常，还算不建议用y总的板子了

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<double> vd;
typedef vector<PII> vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define debug(...) cout << '[debug] ' #__VA_ARGS__ ' = ' << (__VA_ARGS__) << endl;
#define out(x) cout << ((x) ? 'YES' : 'NO') << endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p << 1
#define rc p << 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define rep(i, x, n) for (ll i = x; i <= n; i++)
#define dep(i, x, n) for (ll i = x; i >= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e5 + 10, M = 350, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template <typename T>
bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template <typename T>
bool cmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }
template <typename T>
void sort_range(vector<T> &v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
template <typename T>
struct BIT1
{
    int n;
    vector<T> tr;
    BIT1(int n) : n(n), tr(n + 1) {}
    void add(int x, T v)
    {
        for (; x <= n; x += x & -x)
            tr[x] += v;
    }
    T sum(int x)
    {
        T r = 0;
        for (; x; x -= x & -x)
            r += tr[x];
        return r;
    }
    T range(int l, int r) { return sum(r) - sum(l - 1); }
};
template <typename T>
struct BIT2
{
    int n, m;
    vector<vector<T>> t1, t2, t3, t4;
    BIT2(int n_ = 0, int m_ = 0) { init(n_, m_); }
    void init(int n_, int m_)
    {
        n = n_;
        m = m_;
        t1.assign(n + 1, vector<T>(m + 1, T{}));
        t2.assign(n + 1, vector<T>(m + 1, T{}));
        t3.assign(n + 1, vector<T>(m + 1, T{}));
        t4.assign(n + 1, vector<T>(m + 1, T{}));
    }
    void _add(int x, int y, const T &v)
    {
        for (int i = x; i <= n; i += i & -i)
            for (int j = y; j <= m; j += j & -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    void rangeAdd(int x1, int y1, int x2, int y2, const T &v)
    {
        _add(x1, y1, v);
        _add(x1, y2 + 1, -v);
        _add(x2 + 1, y1, -v);
        _add(x2 + 1, y2 + 1, v);
    }
    T prefixSum(int x, int y)
    {
        T r{};
        for (int i = x; i > 0; i -= i & -i)
            for (int j = y; j > 0; j -= j & -j)
                r += t1[i][j] * (x + 1) * (y + 1) - t2[i][j] * (y + 1) - t3[i][j] * (x + 1) + t4[i][j];
        return r;
    }
    T rangeSum(int x1, int y1, int x2, int y2)
    {
        if (x1 > x2 || y1 > y2)
            return T{};
        return prefixSum(x2, y2) - prefixSum(x1 - 1, y2) - prefixSum(x2, y1 - 1) + prefixSum(x1 - 1, y1 - 1);
    }
};
struct Random
{
    mt19937_64 rng;
    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
    ll rand_ll(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); }
    int rand_int(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); }
    double rand_db(double l, double r) { return uniform_real_distribution<double>(l, r)(rng); }
    bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
    template <typename T>
    void shuffle(vector<T> &v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
    ll res = 1 % p;
    a %= p;
    while (b)
    {
        if (b & 1)
            res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}
/*

*/
ll n, m, len;
ll a[N], add[M], sum[M];
ll get(ll i)
{
    return i / len;
}

void change(ll l, ll r, ll d)
{
    if (get(l) == get(r))
    {
        rep(i, l, r) a[i] += d, sum[get(i)] += d;
    }
    else
    {
        ll i = l, j = r;
        while (get(i) == get(l))
            a[i] += d, sum[get(i)] += d, i++;
        while (get(j) == get(r))
            a[j] += d, sum[get(j)] += d, j--;
        rep(k, get(i), get(j))
        {
            sum[k] += len * d;
            add[k] += d;
        }
    }
}

ll query(ll l, ll r)
{
    ll ret = 0;
    if (get(l) == get(r))
    {
        rep(i, l, r) ret += a[i] + add[get(i)];
    }
    else
    {
        ll i = l, j = r;
        while (get(i) == get(l))
            ret += a[i] + add[get(i)], i++;
        while (get(j) == get(r))
            ret += a[j] + add[get(j)], j--;
        rep(k, get(i), get(j))
        {
            ret += sum[k];
        }
    }
    return ret;
}

void solve()
{
    cin >> n ;
    m=n;
    rep(i, 1, n) cin >> a[i];
    len = sqrt(n);
    rep(i, 1, n)
    {
        sum[get(i)] += a[i];
    }
    while (m--)
    {
        string op;
        cin >> op;
        if (op == '0')
        {
            ll l, r, d;
            cin >> l >> r >> d;
            change(l, r, d);
        }
        else
        {
            ll l, r,d;
            cin >> l >> r>>d;
            ll ans = query(r, r);
            cout << ans << endl;
        }
    }
}

int main()
{
    IOS;

    int _ = 1;
    // cin>>_;//如果是多组数据
    while (_--)
    {
        solve();
    }
    return 0;
}
```
下面的是暂时不卡常的代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
//CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<double> vd;
typedef vector<PII> vPII;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define debug(...) cout << '[debug] ' #__VA_ARGS__ ' = ' << (__VA_ARGS__) << endl;
#define out(x) cout << ((x) ? 'YES' : 'NO') << endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p<<1
#define rc p<<1|1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x)&(-x))
#define rep(i, x, n) for (ll i = x; i <= n; i++)
#define dep(i, x, n) for (ll i = x; i >= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps=1e-5;
const int N = 3e5 + 10,M=550,K=26;
const ll MOD = 1e9 + 7,Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template<typename T> bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template<typename T> bool cmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }
template<typename T> void sort_range(vector<T> &v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
template<typename T> struct BIT1 { int n; vector<T> tr; BIT1(int n) : n(n), tr(n+1) {} void add(int x, T v) { for(;x<=n;x+=x&-x) tr[x]+=v; } T sum(int x) { T r=0; for(;x;x-=x&-x) r+=tr[x]; return r; } T range(int l, int r) { return sum(r)-sum(l-1); } };
template<typename T> struct BIT2 { int n,m; vector<vector<T>> t1,t2,t3,t4; BIT2(int n_=0,int m_=0) { init(n_,m_); } void init(int n_,int m_) { n=n_; m=m_; t1.assign(n+1,vector<T>(m+1,T{})); t2.assign(n+1,vector<T>(m+1,T{})); t3.assign(n+1,vector<T>(m+1,T{})); t4.assign(n+1,vector<T>(m+1,T{})); } void _add(int x,int y,const T& v) { for(int i=x;i<=n;i+=i&-i) for(int j=y;j<=m;j+=j&-j) { t1[i][j]+=v; t2[i][j]+=v*x; t3[i][j]+=v*y; t4[i][j]+=v*x*y; } } void rangeAdd(int x1,int y1,int x2,int y2,const T& v) { _add(x1,y1,v); _add(x1,y2+1,-v); _add(x2+1,y1,-v); _add(x2+1,y2+1,v); } T prefixSum(int x,int y) { T r{}; for(int i=x;i>0;i-=i&-i) for(int j=y;j>0;j-=j&-j) r+=t1[i][j]*(x+1)*(y+1)-t2[i][j]*(y+1)-t3[i][j]*(x+1)+t4[i][j]; return r; } T rangeSum(int x1,int y1,int x2,int y2) { if(x1>x2||y1>y2) return T{}; return prefixSum(x2,y2)-prefixSum(x1-1,y2)-prefixSum(x2,y1-1)+prefixSum(x1-1,y1-1); } };
struct Random { mt19937_64 rng; Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {} ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); } ll rand_ll(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); } int rand_int(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); } double rand_db(double l, double r) { return uniform_real_distribution<double>(l, r)(rng); } bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); } template<typename T> void shuffle(vector<T> &v) { std::shuffle(v.begin(), v.end(), rng); } };
ll qmi(ll a, ll b, ll p) { ll res = 1 % p; a %= p; while (b) { if (b & 1) res = res * a % p; a = a * a % p; b >>= 1; } return res; }
/*
  
*/
ll n, len;
ll a[N], add[M]; // 移除了不必要的sum数组

ll get(ll i) {
    return (i - 1) / len; // 通常块编号从0开始，或者用(i-1)/len +1从1开始，这里根据你的习惯调整。">
<meta property="og:title" content="分块入门9题">
<meta property="og:description" content="## 数列分块入门1

<img width='1263' height='1329' alt='Image' src='https://github.com/user-attachments/assets/ba9b3ade-2373-493e-a2a8-c0d527fd1700' />

>第一题是y总的板子，但是y总的分块就讲了这个基础题目，我觉得还是太浅了，后来讲的就是链表分块，但是后来我去洛谷交了一个数据大一点点的题目，发现会卡常，还算不建议用y总的板子了

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<double> vd;
typedef vector<PII> vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define debug(...) cout << '[debug] ' #__VA_ARGS__ ' = ' << (__VA_ARGS__) << endl;
#define out(x) cout << ((x) ? 'YES' : 'NO') << endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p << 1
#define rc p << 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define rep(i, x, n) for (ll i = x; i <= n; i++)
#define dep(i, x, n) for (ll i = x; i >= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e5 + 10, M = 350, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template <typename T>
bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template <typename T>
bool cmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }
template <typename T>
void sort_range(vector<T> &v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
template <typename T>
struct BIT1
{
    int n;
    vector<T> tr;
    BIT1(int n) : n(n), tr(n + 1) {}
    void add(int x, T v)
    {
        for (; x <= n; x += x & -x)
            tr[x] += v;
    }
    T sum(int x)
    {
        T r = 0;
        for (; x; x -= x & -x)
            r += tr[x];
        return r;
    }
    T range(int l, int r) { return sum(r) - sum(l - 1); }
};
template <typename T>
struct BIT2
{
    int n, m;
    vector<vector<T>> t1, t2, t3, t4;
    BIT2(int n_ = 0, int m_ = 0) { init(n_, m_); }
    void init(int n_, int m_)
    {
        n = n_;
        m = m_;
        t1.assign(n + 1, vector<T>(m + 1, T{}));
        t2.assign(n + 1, vector<T>(m + 1, T{}));
        t3.assign(n + 1, vector<T>(m + 1, T{}));
        t4.assign(n + 1, vector<T>(m + 1, T{}));
    }
    void _add(int x, int y, const T &v)
    {
        for (int i = x; i <= n; i += i & -i)
            for (int j = y; j <= m; j += j & -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    void rangeAdd(int x1, int y1, int x2, int y2, const T &v)
    {
        _add(x1, y1, v);
        _add(x1, y2 + 1, -v);
        _add(x2 + 1, y1, -v);
        _add(x2 + 1, y2 + 1, v);
    }
    T prefixSum(int x, int y)
    {
        T r{};
        for (int i = x; i > 0; i -= i & -i)
            for (int j = y; j > 0; j -= j & -j)
                r += t1[i][j] * (x + 1) * (y + 1) - t2[i][j] * (y + 1) - t3[i][j] * (x + 1) + t4[i][j];
        return r;
    }
    T rangeSum(int x1, int y1, int x2, int y2)
    {
        if (x1 > x2 || y1 > y2)
            return T{};
        return prefixSum(x2, y2) - prefixSum(x1 - 1, y2) - prefixSum(x2, y1 - 1) + prefixSum(x1 - 1, y1 - 1);
    }
};
struct Random
{
    mt19937_64 rng;
    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
    ll rand_ll(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); }
    int rand_int(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); }
    double rand_db(double l, double r) { return uniform_real_distribution<double>(l, r)(rng); }
    bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
    template <typename T>
    void shuffle(vector<T> &v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
    ll res = 1 % p;
    a %= p;
    while (b)
    {
        if (b & 1)
            res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}
/*

*/
ll n, m, len;
ll a[N], add[M], sum[M];
ll get(ll i)
{
    return i / len;
}

void change(ll l, ll r, ll d)
{
    if (get(l) == get(r))
    {
        rep(i, l, r) a[i] += d, sum[get(i)] += d;
    }
    else
    {
        ll i = l, j = r;
        while (get(i) == get(l))
            a[i] += d, sum[get(i)] += d, i++;
        while (get(j) == get(r))
            a[j] += d, sum[get(j)] += d, j--;
        rep(k, get(i), get(j))
        {
            sum[k] += len * d;
            add[k] += d;
        }
    }
}

ll query(ll l, ll r)
{
    ll ret = 0;
    if (get(l) == get(r))
    {
        rep(i, l, r) ret += a[i] + add[get(i)];
    }
    else
    {
        ll i = l, j = r;
        while (get(i) == get(l))
            ret += a[i] + add[get(i)], i++;
        while (get(j) == get(r))
            ret += a[j] + add[get(j)], j--;
        rep(k, get(i), get(j))
        {
            ret += sum[k];
        }
    }
    return ret;
}

void solve()
{
    cin >> n ;
    m=n;
    rep(i, 1, n) cin >> a[i];
    len = sqrt(n);
    rep(i, 1, n)
    {
        sum[get(i)] += a[i];
    }
    while (m--)
    {
        string op;
        cin >> op;
        if (op == '0')
        {
            ll l, r, d;
            cin >> l >> r >> d;
            change(l, r, d);
        }
        else
        {
            ll l, r,d;
            cin >> l >> r>>d;
            ll ans = query(r, r);
            cout << ans << endl;
        }
    }
}

int main()
{
    IOS;

    int _ = 1;
    // cin>>_;//如果是多组数据
    while (_--)
    {
        solve();
    }
    return 0;
}
```
下面的是暂时不卡常的代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
//CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<double> vd;
typedef vector<PII> vPII;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define debug(...) cout << '[debug] ' #__VA_ARGS__ ' = ' << (__VA_ARGS__) << endl;
#define out(x) cout << ((x) ? 'YES' : 'NO') << endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p<<1
#define rc p<<1|1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x)&(-x))
#define rep(i, x, n) for (ll i = x; i <= n; i++)
#define dep(i, x, n) for (ll i = x; i >= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps=1e-5;
const int N = 3e5 + 10,M=550,K=26;
const ll MOD = 1e9 + 7,Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template<typename T> bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template<typename T> bool cmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }
template<typename T> void sort_range(vector<T> &v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
template<typename T> struct BIT1 { int n; vector<T> tr; BIT1(int n) : n(n), tr(n+1) {} void add(int x, T v) { for(;x<=n;x+=x&-x) tr[x]+=v; } T sum(int x) { T r=0; for(;x;x-=x&-x) r+=tr[x]; return r; } T range(int l, int r) { return sum(r)-sum(l-1); } };
template<typename T> struct BIT2 { int n,m; vector<vector<T>> t1,t2,t3,t4; BIT2(int n_=0,int m_=0) { init(n_,m_); } void init(int n_,int m_) { n=n_; m=m_; t1.assign(n+1,vector<T>(m+1,T{})); t2.assign(n+1,vector<T>(m+1,T{})); t3.assign(n+1,vector<T>(m+1,T{})); t4.assign(n+1,vector<T>(m+1,T{})); } void _add(int x,int y,const T& v) { for(int i=x;i<=n;i+=i&-i) for(int j=y;j<=m;j+=j&-j) { t1[i][j]+=v; t2[i][j]+=v*x; t3[i][j]+=v*y; t4[i][j]+=v*x*y; } } void rangeAdd(int x1,int y1,int x2,int y2,const T& v) { _add(x1,y1,v); _add(x1,y2+1,-v); _add(x2+1,y1,-v); _add(x2+1,y2+1,v); } T prefixSum(int x,int y) { T r{}; for(int i=x;i>0;i-=i&-i) for(int j=y;j>0;j-=j&-j) r+=t1[i][j]*(x+1)*(y+1)-t2[i][j]*(y+1)-t3[i][j]*(x+1)+t4[i][j]; return r; } T rangeSum(int x1,int y1,int x2,int y2) { if(x1>x2||y1>y2) return T{}; return prefixSum(x2,y2)-prefixSum(x1-1,y2)-prefixSum(x2,y1-1)+prefixSum(x1-1,y1-1); } };
struct Random { mt19937_64 rng; Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {} ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); } ll rand_ll(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); } int rand_int(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); } double rand_db(double l, double r) { return uniform_real_distribution<double>(l, r)(rng); } bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); } template<typename T> void shuffle(vector<T> &v) { std::shuffle(v.begin(), v.end(), rng); } };
ll qmi(ll a, ll b, ll p) { ll res = 1 % p; a %= p; while (b) { if (b & 1) res = res * a % p; a = a * a % p; b >>= 1; } return res; }
/*
  
*/
ll n, len;
ll a[N], add[M]; // 移除了不必要的sum数组

ll get(ll i) {
    return (i - 1) / len; // 通常块编号从0开始，或者用(i-1)/len +1从1开始，这里根据你的习惯调整。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhezhi198.github.io/post/fen-kuai-ru-men-9-ti.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>分块入门9题</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">分块入门9题</h1>
<div class="title-right">
    <a href="https://zhezhi198.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/zhezhi198/zhezhi198.github.io/issues/9" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>数列分块入门1</h2>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/ba9b3ade-2373-493e-a2a8-c0d527fd1700"><img width="1263" height="1329" alt="Image" src="https://github.com/user-attachments/assets/ba9b3ade-2373-493e-a2a8-c0d527fd1700" style="max-width: 100%; height: auto; max-height: 1329px;"></a></p>
<blockquote>
<p>第一题是y总的板子，但是y总的分块就讲了这个基础题目，我觉得还是太浅了，后来讲的就是链表分块，但是后来我去洛谷交了一个数据大一点点的题目，发现会卡常，还算不建议用y总的板子了</p>
</blockquote>
<p>代码：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">1e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">350</span>, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT1</span>
{
    <span class="pl-k">int</span> n;
    vector&lt;T&gt; tr;
    <span class="pl-en">BIT1</span>(<span class="pl-k">int</span> n) : n(n), tr(n + <span class="pl-c1">1</span>) {}
    <span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> x, T v)
    {
        <span class="pl-k">for</span> (; x &lt;= n; x += x &amp; -x)
            tr[x] += v;
    }
    T <span class="pl-en">sum</span>(<span class="pl-k">int</span> x)
    {
        T r = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (; x; x -= x &amp; -x)
            r += tr[x];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">range</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> <span class="pl-c1">sum</span>(r) - <span class="pl-c1">sum</span>(l - <span class="pl-c1">1</span>); }
};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT2</span>
{
    <span class="pl-k">int</span> n, m;
    vector&lt;vector&lt;T&gt;&gt; t1, t2, t3, t4;
    <span class="pl-en">BIT2</span>(<span class="pl-k">int</span> n_ = <span class="pl-c1">0</span>, <span class="pl-k">int</span> m_ = <span class="pl-c1">0</span>) { <span class="pl-c1">init</span>(n_, m_); }
    <span class="pl-k">void</span> <span class="pl-en">init</span>(<span class="pl-k">int</span> n_, <span class="pl-k">int</span> m_)
    {
        n = n_;
        m = m_;
        t1.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t2.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t3.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t4.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
    }
    <span class="pl-k">void</span> <span class="pl-en">_add</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &lt;= n; i += i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &lt;= m; j += j &amp; -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    <span class="pl-k">void</span> <span class="pl-en">rangeAdd</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-c1">_add</span>(x1, y1, v);
        <span class="pl-c1">_add</span>(x1, y2 + <span class="pl-c1">1</span>, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y1, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y2 + <span class="pl-c1">1</span>, v);
    }
    T <span class="pl-en">prefixSum</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y)
    {
        T r{};
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &gt; <span class="pl-c1">0</span>; i -= i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &gt; <span class="pl-c1">0</span>; j -= j &amp; -j)
                r += t1[i][j] * (x + <span class="pl-c1">1</span>) * (y + <span class="pl-c1">1</span>) - t2[i][j] * (y + <span class="pl-c1">1</span>) - t3[i][j] * (x + <span class="pl-c1">1</span>) + t4[i][j];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">rangeSum</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2)
    {
        <span class="pl-k">if</span> (x1 &gt; x2 || y1 &gt; y2)
            <span class="pl-k">return</span> T{};
        <span class="pl-k">return</span> <span class="pl-c1">prefixSum</span>(x2, y2) - <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y2) - <span class="pl-c1">prefixSum</span>(x2, y1 - <span class="pl-c1">1</span>) + <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y1 - <span class="pl-c1">1</span>);
    }
};
<span class="pl-k">struct</span> <span class="pl-en">Random</span>
{
    mt19937_64 rng;
    <span class="pl-en">Random</span>() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); }
    ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); }
    <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); }
    <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); }
    <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
    <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); }
};
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p)
{
    ll res = <span class="pl-c1">1</span> % p;
    a %= p;
    <span class="pl-k">while</span> (b)
    {
        <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> res;
}
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>
ll n, m, len;
ll a[N], add[M], sum[M];
ll <span class="pl-en">get</span>(ll i)
{
    <span class="pl-k">return</span> i / len;
}

<span class="pl-k">void</span> <span class="pl-en">change</span>(ll l, ll r, ll d)
{
    <span class="pl-k">if</span> (<span class="pl-c1">get</span>(l) == <span class="pl-c1">get</span>(r))
    {
        <span class="pl-c1">rep</span>(i, l, r) a[i] += d, sum[<span class="pl-c1">get</span>(i)] += d;
    }
    <span class="pl-k">else</span>
    {
        ll i = l, j = r;
        <span class="pl-k">while</span> (<span class="pl-c1">get</span>(i) == <span class="pl-c1">get</span>(l))
            a[i] += d, sum[<span class="pl-c1">get</span>(i)] += d, i++;
        <span class="pl-k">while</span> (<span class="pl-c1">get</span>(j) == <span class="pl-c1">get</span>(r))
            a[j] += d, sum[<span class="pl-c1">get</span>(j)] += d, j--;
        <span class="pl-c1">rep</span>(k, <span class="pl-c1">get</span>(i), <span class="pl-c1">get</span>(j))
        {
            sum[k] += len * d;
            add[k] += d;
        }
    }
}

ll <span class="pl-en">query</span>(ll l, ll r)
{
    ll ret = <span class="pl-c1">0</span>;
    <span class="pl-k">if</span> (<span class="pl-c1">get</span>(l) == <span class="pl-c1">get</span>(r))
    {
        <span class="pl-c1">rep</span>(i, l, r) ret += a[i] + add[<span class="pl-c1">get</span>(i)];
    }
    <span class="pl-k">else</span>
    {
        ll i = l, j = r;
        <span class="pl-k">while</span> (<span class="pl-c1">get</span>(i) == <span class="pl-c1">get</span>(l))
            ret += a[i] + add[<span class="pl-c1">get</span>(i)], i++;
        <span class="pl-k">while</span> (<span class="pl-c1">get</span>(j) == <span class="pl-c1">get</span>(r))
            ret += a[j] + add[<span class="pl-c1">get</span>(j)], j--;
        <span class="pl-c1">rep</span>(k, <span class="pl-c1">get</span>(i), <span class="pl-c1">get</span>(j))
        {
            ret += sum[k];
        }
    }
    <span class="pl-k">return</span> ret;
}

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    cin &gt;&gt; n ;
    m=n;
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n) cin &gt;&gt; a[i];
    len = <span class="pl-c1">sqrt</span>(n);
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        sum[<span class="pl-c1">get</span>(i)] += a[i];
    }
    <span class="pl-k">while</span> (m--)
    {
        string op;
        cin &gt;&gt; op;
        <span class="pl-k">if</span> (op == <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>)
        {
            ll l, r, d;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;
            <span class="pl-c1">change</span>(l, r, d);
        }
        <span class="pl-k">else</span>
        {
            ll l, r,d;
            cin &gt;&gt; l &gt;&gt; r&gt;&gt;d;
            ll ans = <span class="pl-c1">query</span>(r, r);
            cout &lt;&lt; ans &lt;&lt; endl;
        }
    }
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    <span class="pl-c"><span class="pl-c">//</span> cin&gt;&gt;_;//如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>下面的是暂时不卡常的代码:</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span>CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span> <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); cin.tie(<span class="pl-c1">0</span>); cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p&lt;&lt;<span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p&lt;&lt;<span class="pl-c1">1</span>|<span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x)&amp;(-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps=<span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">3e5</span> + <span class="pl-c1">10</span>,M=<span class="pl-c1">550</span>,K=<span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>,Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">struct</span> <span class="pl-en">BIT1</span> { <span class="pl-k">int</span> n; vector&lt;T&gt; tr; BIT1(<span class="pl-k">int</span> n) : n(n), tr(n+<span class="pl-c1">1</span>) {} <span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> x, T v) { <span class="pl-k">for</span>(;x&lt;=n;x+=x&amp;-x) tr[x]+=v; } T <span class="pl-en">sum</span>(<span class="pl-k">int</span> x) { T r=<span class="pl-c1">0</span>; <span class="pl-k">for</span>(;x;x-=x&amp;-x) r+=tr[x]; <span class="pl-k">return</span> r; } T <span class="pl-en">range</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> <span class="pl-c1">sum</span>(r)-<span class="pl-c1">sum</span>(l-<span class="pl-c1">1</span>); } };
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">struct</span> <span class="pl-en">BIT2</span> { <span class="pl-k">int</span> n,m; vector&lt;vector&lt;T&gt;&gt; t1,t2,t3,t4; BIT2(<span class="pl-k">int</span> n_=<span class="pl-c1">0</span>,<span class="pl-k">int</span> m_=<span class="pl-c1">0</span>) { <span class="pl-c1">init</span>(n_,m_); } <span class="pl-k">void</span> <span class="pl-en">init</span>(<span class="pl-k">int</span> n_,<span class="pl-k">int</span> m_) { n=n_; m=m_; t1.<span class="pl-c1">assign</span>(n+<span class="pl-c1">1</span>,vector&lt;T&gt;(m+<span class="pl-c1">1</span>,T{})); t2.<span class="pl-c1">assign</span>(n+<span class="pl-c1">1</span>,vector&lt;T&gt;(m+<span class="pl-c1">1</span>,T{})); t3.<span class="pl-c1">assign</span>(n+<span class="pl-c1">1</span>,vector&lt;T&gt;(m+<span class="pl-c1">1</span>,T{})); t4.<span class="pl-c1">assign</span>(n+<span class="pl-c1">1</span>,vector&lt;T&gt;(m+<span class="pl-c1">1</span>,T{})); } <span class="pl-k">void</span> <span class="pl-en">_add</span>(<span class="pl-k">int</span> x,<span class="pl-k">int</span> y,<span class="pl-k">const</span> T&amp; v) { <span class="pl-k">for</span>(<span class="pl-k">int</span> i=x;i&lt;=n;i+=i&amp;-i) <span class="pl-k">for</span>(<span class="pl-k">int</span> j=y;j&lt;=m;j+=j&amp;-j) { t1[i][j]+=v; t2[i][j]+=v*x; t3[i][j]+=v*y; t4[i][j]+=v*x*y; } } <span class="pl-k">void</span> <span class="pl-en">rangeAdd</span>(<span class="pl-k">int</span> x1,<span class="pl-k">int</span> y1,<span class="pl-k">int</span> x2,<span class="pl-k">int</span> y2,<span class="pl-k">const</span> T&amp; v) { <span class="pl-c1">_add</span>(x1,y1,v); <span class="pl-c1">_add</span>(x1,y2+<span class="pl-c1">1</span>,-v); <span class="pl-c1">_add</span>(x2+<span class="pl-c1">1</span>,y1,-v); <span class="pl-c1">_add</span>(x2+<span class="pl-c1">1</span>,y2+<span class="pl-c1">1</span>,v); } T <span class="pl-en">prefixSum</span>(<span class="pl-k">int</span> x,<span class="pl-k">int</span> y) { T r{}; <span class="pl-k">for</span>(<span class="pl-k">int</span> i=x;i&gt;<span class="pl-c1">0</span>;i-=i&amp;-i) <span class="pl-k">for</span>(<span class="pl-k">int</span> j=y;j&gt;<span class="pl-c1">0</span>;j-=j&amp;-j) r+=t1[i][j]*(x+<span class="pl-c1">1</span>)*(y+<span class="pl-c1">1</span>)-t2[i][j]*(y+<span class="pl-c1">1</span>)-t3[i][j]*(x+<span class="pl-c1">1</span>)+t4[i][j]; <span class="pl-k">return</span> r; } T <span class="pl-en">rangeSum</span>(<span class="pl-k">int</span> x1,<span class="pl-k">int</span> y1,<span class="pl-k">int</span> x2,<span class="pl-k">int</span> y2) { <span class="pl-k">if</span>(x1&gt;x2||y1&gt;y2) <span class="pl-k">return</span> T{}; <span class="pl-k">return</span> <span class="pl-c1">prefixSum</span>(x2,y2)-<span class="pl-c1">prefixSum</span>(x1-<span class="pl-c1">1</span>,y2)-<span class="pl-c1">prefixSum</span>(x2,y1-<span class="pl-c1">1</span>)+<span class="pl-c1">prefixSum</span>(x1-<span class="pl-c1">1</span>,y1-<span class="pl-c1">1</span>); } };
<span class="pl-k">struct</span> <span class="pl-en">Random</span> { mt19937_64 rng; Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {} ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); } ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); } <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); } <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); } <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); } <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt; <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); } };
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p) { ll res = <span class="pl-c1">1</span> % p; a %= p; <span class="pl-k">while</span> (b) { <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>) res = res * a % p; a = a * a % p; b &gt;&gt;= <span class="pl-c1">1</span>; } <span class="pl-k">return</span> res; }
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">  </span>
<span class="pl-c"><span class="pl-c">*/</span></span>
ll n, len;
ll a[N], add[M]; <span class="pl-c"><span class="pl-c">//</span> 移除了不必要的sum数组</span>

ll <span class="pl-en">get</span>(ll i) {
    <span class="pl-k">return</span> (i - <span class="pl-c1">1</span>) / len; <span class="pl-c"><span class="pl-c">//</span> 通常块编号从0开始，或者用(i-1)/len +1从1开始，这里根据你的习惯调整。注意与后续操作匹配。</span>
}

<span class="pl-k">void</span> <span class="pl-en">change</span>(ll l, ll r, ll d) {
    <span class="pl-k">int</span> bl = <span class="pl-c1">get</span>(l), br = <span class="pl-c1">get</span>(r);
    <span class="pl-k">if</span> (bl == br) {
        <span class="pl-c"><span class="pl-c">//</span> 情况1：l和r在同一个块内，暴力修改</span>
        <span class="pl-k">for</span> (ll i = l; i &lt;= r; i++) {
            a[i] += d;
        }
    } <span class="pl-k">else</span> {
        <span class="pl-c"><span class="pl-c">//</span> 情况2：跨块</span>
        <span class="pl-c"><span class="pl-c">//</span> 处理左侧不完整块</span>
        <span class="pl-k">for</span> (ll i = l; i &lt;= (bl + <span class="pl-c1">1</span>) * len; i++) { <span class="pl-c"><span class="pl-c">//</span> 假设块编号从0开始，bl是l所在的块</span>
            a[i] += d;
        }
        <span class="pl-c"><span class="pl-c">//</span> 处理右侧不完整块</span>
        <span class="pl-k">for</span> (ll i = br * len + <span class="pl-c1">1</span>; i &lt;= r; i++) { <span class="pl-c"><span class="pl-c">//</span> br是r所在的块</span>
            a[i] += d;
        }
        <span class="pl-c"><span class="pl-c">//</span> 处理中间的完整块</span>
        <span class="pl-k">for</span> (<span class="pl-k">int</span> k = bl + <span class="pl-c1">1</span>; k &lt; br; k++) {
            add[k] += d;
        }
    }
}

<span class="pl-k">void</span> <span class="pl-en">solve</span>() {
    cin &gt;&gt; n;
    len = <span class="pl-c1">sqrt</span>(n); <span class="pl-c"><span class="pl-c">//</span> 块的大小</span>
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">1</span>; i &lt;= n; i++) {
        cin &gt;&gt; a[i];
    }

    <span class="pl-k">int</span> m = n;
    <span class="pl-k">while</span> (m--) {
        <span class="pl-k">int</span> opt;
        ll l, r, c;
        cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;
        <span class="pl-k">if</span> (opt == <span class="pl-c1">0</span>) {
            <span class="pl-c1">change</span>(l, r, c);
        } <span class="pl-k">else</span> {
            <span class="pl-c"><span class="pl-c">//</span> 单点查询：直接输出 a[r] + 其所在块的add标记</span>
            cout &lt;&lt; a[r] + add[<span class="pl-c1">get</span>(r)] &lt;&lt; endl;
        }
    }
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    IOS;
    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (_--) {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>数列分块入门2</h2>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/e6e2db24-4291-4558-a01a-ba5af079bd07"><img width="2000" height="1332" alt="Image" src="https://github.com/user-attachments/assets/e6e2db24-4291-4558-a01a-ba5af079bd07" style="max-width: 100%; height: auto; max-height: 1332px;"></a></p>
<p>代码：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">1e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">350</span>, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT1</span>
{
    <span class="pl-k">int</span> n;
    vector&lt;T&gt; tr;
    <span class="pl-en">BIT1</span>(<span class="pl-k">int</span> n) : n(n), tr(n + <span class="pl-c1">1</span>) {}
    <span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> x, T v)
    {
        <span class="pl-k">for</span> (; x &lt;= n; x += x &amp; -x)
            tr[x] += v;
    }
    T <span class="pl-en">sum</span>(<span class="pl-k">int</span> x)
    {
        T r = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (; x; x -= x &amp; -x)
            r += tr[x];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">range</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> <span class="pl-c1">sum</span>(r) - <span class="pl-c1">sum</span>(l - <span class="pl-c1">1</span>); }
};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT2</span>
{
    <span class="pl-k">int</span> n, m;
    vector&lt;vector&lt;T&gt;&gt; t1, t2, t3, t4;
    <span class="pl-en">BIT2</span>(<span class="pl-k">int</span> n_ = <span class="pl-c1">0</span>, <span class="pl-k">int</span> m_ = <span class="pl-c1">0</span>) { <span class="pl-c1">init</span>(n_, m_); }
    <span class="pl-k">void</span> <span class="pl-en">init</span>(<span class="pl-k">int</span> n_, <span class="pl-k">int</span> m_)
    {
        n = n_;
        m = m_;
        t1.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t2.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t3.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t4.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
    }
    <span class="pl-k">void</span> <span class="pl-en">_add</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &lt;= n; i += i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &lt;= m; j += j &amp; -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    <span class="pl-k">void</span> <span class="pl-en">rangeAdd</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-c1">_add</span>(x1, y1, v);
        <span class="pl-c1">_add</span>(x1, y2 + <span class="pl-c1">1</span>, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y1, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y2 + <span class="pl-c1">1</span>, v);
    }
    T <span class="pl-en">prefixSum</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y)
    {
        T r{};
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &gt; <span class="pl-c1">0</span>; i -= i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &gt; <span class="pl-c1">0</span>; j -= j &amp; -j)
                r += t1[i][j] * (x + <span class="pl-c1">1</span>) * (y + <span class="pl-c1">1</span>) - t2[i][j] * (y + <span class="pl-c1">1</span>) - t3[i][j] * (x + <span class="pl-c1">1</span>) + t4[i][j];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">rangeSum</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2)
    {
        <span class="pl-k">if</span> (x1 &gt; x2 || y1 &gt; y2)
            <span class="pl-k">return</span> T{};
        <span class="pl-k">return</span> <span class="pl-c1">prefixSum</span>(x2, y2) - <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y2) - <span class="pl-c1">prefixSum</span>(x2, y1 - <span class="pl-c1">1</span>) + <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y1 - <span class="pl-c1">1</span>);
    }
};
<span class="pl-k">struct</span> <span class="pl-en">Random</span>
{
    mt19937_64 rng;
    <span class="pl-en">Random</span>() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); }
    ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); }
    <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); }
    <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); }
    <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
    <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); }
};
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p)
{
    ll res = <span class="pl-c1">1</span> % p;
    a %= p;
    <span class="pl-k">while</span> (b)
    {
        <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> res;
}
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>

ll n, len;
ll a[N], add[M];
vll sorted[M];

ll <span class="pl-en">get</span>(ll i)
{
    <span class="pl-k">return</span> (i - <span class="pl-c1">1</span>) / len + <span class="pl-c1">1</span>;
}

<span class="pl-k">void</span> <span class="pl-en">build</span>(ll block)
{
    ll st = (block - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>;
    ll ed = <span class="pl-c1">min</span>((block)*len, n);
    sorted[block].<span class="pl-c1">clear</span>();
    <span class="pl-c1">rep</span>(i, st, ed)
    {
        sorted[block].<span class="pl-c1">push_back</span>(a[i]);
    }
    <span class="pl-c1">sort</span>(<span class="pl-c1">all</span>(sorted[block]));
}

<span class="pl-k">void</span> <span class="pl-en">change</span>(ll l, ll r, ll d)
{
    ll bl = <span class="pl-c1">get</span>(l), br = <span class="pl-c1">get</span>(r);
    <span class="pl-k">if</span> (bl == br)
    {
        <span class="pl-c1">rep</span>(i, l, r) a[i] += d;
        <span class="pl-c1">build</span>(bl);
    }
    <span class="pl-k">else</span>
    {
        <span class="pl-c1">rep</span>(i, l, (bl)*len) a[i] += d;
        <span class="pl-c1">build</span>(bl);
        <span class="pl-c1">rep</span>(i, (br - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>, r) a[i] += d;
        <span class="pl-c1">build</span>(br);
        <span class="pl-c1">rep</span>(i, bl + <span class="pl-c1">1</span>, br - <span class="pl-c1">1</span>) add[i] += d;
    }
}

ll <span class="pl-en">query_less</span>(ll l, ll r, ll c)
{
    ll x = c * c;
    ll bl = <span class="pl-c1">get</span>(l), br = <span class="pl-c1">get</span>(r);
    ll ans = <span class="pl-c1">0</span>;
    <span class="pl-k">if</span> (bl == br)
    {
        <span class="pl-c1">rep</span>(i, l, r)
        {
            <span class="pl-k">if</span> (a[i] + add[bl] &lt; x)
                ans++;
        }
    }
    <span class="pl-k">else</span>
    {
        <span class="pl-c1">rep</span>(i, l, bl * len)
        {
            <span class="pl-k">if</span> (a[i] + add[bl] &lt; x)
                ans++;
        }
        <span class="pl-c1">rep</span>(i, (br - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>, r)
        {
            <span class="pl-k">if</span> (a[i] + add[br] &lt; x)
                ans++;
        }
        <span class="pl-c1">rep</span>(i, bl + <span class="pl-c1">1</span>, br - <span class="pl-c1">1</span>)
        {
            ll d = x - add[i];
            ll pos = <span class="pl-c1">lower_bound</span>(<span class="pl-c1">all</span>(sorted[i]), d) - sorted[i].<span class="pl-c1">begin</span>();
            ans += pos;
        }
    }
    <span class="pl-k">return</span> ans;
}

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
   
    cin &gt;&gt; n;
    len = <span class="pl-c1">sqrt</span>(n);
    ll t = <span class="pl-c1">get</span>(n);
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n) cin &gt;&gt; a[i];
     <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, t)
    {
        add[i] = <span class="pl-c1">0</span>;
        <span class="pl-c1">build</span>(i);
    }
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        ll op, l, r, d;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; d;
        <span class="pl-k">if</span> (op == <span class="pl-c1">0</span>)
        {
            <span class="pl-c1">change</span>(l, r, d);
        }
        <span class="pl-k">else</span>
        {
            ll ans = <span class="pl-c1">query_less</span>(l, r, d);
            cout &lt;&lt; ans &lt;&lt; endl;
        }
    }
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    <span class="pl-c"><span class="pl-c">//</span> cin&gt;&gt;_;//如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>数列分块入门3</h2>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/2fc0e7c6-5828-4e2e-8397-8de345a30343"><img width="591" height="821" alt="Image" src="https://github.com/user-attachments/assets/2fc0e7c6-5828-4e2e-8397-8de345a30343" style="max-width: 100%; height: auto; max-height: 821px;"></a></p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">2e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">550</span>, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT1</span>
{
    <span class="pl-k">int</span> n;
    vector&lt;T&gt; tr;
    <span class="pl-en">BIT1</span>(<span class="pl-k">int</span> n) : n(n), tr(n + <span class="pl-c1">1</span>) {}
    <span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> x, T v)
    {
        <span class="pl-k">for</span> (; x &lt;= n; x += x &amp; -x)
            tr[x] += v;
    }
    T <span class="pl-en">sum</span>(<span class="pl-k">int</span> x)
    {
        T r = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (; x; x -= x &amp; -x)
            r += tr[x];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">range</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> <span class="pl-c1">sum</span>(r) - <span class="pl-c1">sum</span>(l - <span class="pl-c1">1</span>); }
};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT2</span>
{
    <span class="pl-k">int</span> n, m;
    vector&lt;vector&lt;T&gt;&gt; t1, t2, t3, t4;
    <span class="pl-en">BIT2</span>(<span class="pl-k">int</span> n_ = <span class="pl-c1">0</span>, <span class="pl-k">int</span> m_ = <span class="pl-c1">0</span>) { <span class="pl-c1">init</span>(n_, m_); }
    <span class="pl-k">void</span> <span class="pl-en">init</span>(<span class="pl-k">int</span> n_, <span class="pl-k">int</span> m_)
    {
        n = n_;
        m = m_;
        t1.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t2.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t3.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t4.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
    }
    <span class="pl-k">void</span> <span class="pl-en">_add</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &lt;= n; i += i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &lt;= m; j += j &amp; -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    <span class="pl-k">void</span> <span class="pl-en">rangeAdd</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-c1">_add</span>(x1, y1, v);
        <span class="pl-c1">_add</span>(x1, y2 + <span class="pl-c1">1</span>, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y1, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y2 + <span class="pl-c1">1</span>, v);
    }
    T <span class="pl-en">prefixSum</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y)
    {
        T r{};
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &gt; <span class="pl-c1">0</span>; i -= i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &gt; <span class="pl-c1">0</span>; j -= j &amp; -j)
                r += t1[i][j] * (x + <span class="pl-c1">1</span>) * (y + <span class="pl-c1">1</span>) - t2[i][j] * (y + <span class="pl-c1">1</span>) - t3[i][j] * (x + <span class="pl-c1">1</span>) + t4[i][j];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">rangeSum</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2)
    {
        <span class="pl-k">if</span> (x1 &gt; x2 || y1 &gt; y2)
            <span class="pl-k">return</span> T{};
        <span class="pl-k">return</span> <span class="pl-c1">prefixSum</span>(x2, y2) - <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y2) - <span class="pl-c1">prefixSum</span>(x2, y1 - <span class="pl-c1">1</span>) + <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y1 - <span class="pl-c1">1</span>);
    }
};
<span class="pl-k">struct</span> <span class="pl-en">Random</span>
{
    mt19937_64 rng;
    <span class="pl-en">Random</span>() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); }
    ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); }
    <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); }
    <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); }
    <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
    <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); }
};
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p)
{
    ll res = <span class="pl-c1">1</span> % p;
    a %= p;
    <span class="pl-k">while</span> (b)
    {
        <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> res;
}
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>

ll n, len;
ll a[N], add[M];
vll tmp[M];
ll <span class="pl-en">get</span>(ll i)
{
    <span class="pl-k">return</span> (i - <span class="pl-c1">1</span>) / len + <span class="pl-c1">1</span>;
}

<span class="pl-k">void</span> <span class="pl-en">build</span>(ll block)
{
    ll st = (block - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>;
    ll ed = <span class="pl-c1">min</span>(block * len, n);
    tmp[block].<span class="pl-c1">clear</span>();
    <span class="pl-c1">rep</span>(i, st, ed)
    {
        tmp[block].<span class="pl-c1">push_back</span>(a[i]);
    }
    <span class="pl-c1">sort</span>(<span class="pl-c1">all</span>(tmp[block]));
}

<span class="pl-k">void</span> <span class="pl-en">change</span>(ll l, ll r, ll d)
{
    ll bl = <span class="pl-c1">get</span>(l), br = <span class="pl-c1">get</span>(r);
    <span class="pl-k">if</span> (bl == br)
    {
        <span class="pl-c1">rep</span>(i, l, r) a[i] += d;
        <span class="pl-c1">build</span>(bl);
    }
    <span class="pl-k">else</span>
    {
        <span class="pl-c1">rep</span>(i, l, <span class="pl-c1">min</span>(bl * len, n)) a[i] += d;
        <span class="pl-c1">build</span>(bl);
        <span class="pl-c1">rep</span>(i, (br - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>, r) a[i] += d;
        <span class="pl-c1">build</span>(br);
        <span class="pl-c1">rep</span>(i, bl + <span class="pl-c1">1</span>, br - <span class="pl-c1">1</span>) add[i] += d;
    }
}

ll <span class="pl-en">query</span>(ll l, ll r, ll c)
{
    ll bl = <span class="pl-c1">get</span>(l), br = <span class="pl-c1">get</span>(r);
    ll ans = -INF;
    <span class="pl-k">if</span> (bl == br)
    {
        <span class="pl-c1">rep</span>(i, l, r)
        {
            <span class="pl-k">if</span> (a[i] + add[bl] &lt; c)
                <span class="pl-c1">cmax</span>(ans, a[i] + add[bl]);
        }
        <span class="pl-k">if</span> (ans == -INF)
            <span class="pl-k">return</span> -<span class="pl-c1">1</span>;
        <span class="pl-k">return</span> ans;
    }
    <span class="pl-k">else</span>
    {
        <span class="pl-c1">rep</span>(i, l, <span class="pl-c1">min</span>(bl * len, n))
        {
            <span class="pl-k">if</span> (a[i] + add[bl] &lt; c)
                <span class="pl-c1">cmax</span>(ans, a[i] + add[bl]);
        }
        <span class="pl-c1">rep</span>(i, (br - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>, r)
        {
            <span class="pl-k">if</span> (a[i] + add[br] &lt; c)
                <span class="pl-c1">cmax</span>(ans, a[i] + add[br]);
        }
        <span class="pl-c1">rep</span>(i, bl + <span class="pl-c1">1</span>, br - <span class="pl-c1">1</span>)
        {
            ll d = c - add[i];
            ll num = <span class="pl-c1">lower_bound</span>(<span class="pl-c1">all</span>(tmp[i]), d) - tmp[i].<span class="pl-c1">begin</span>();

            <span class="pl-k">auto</span> it = <span class="pl-c1">lower_bound</span>(<span class="pl-c1">all</span>(tmp[i]), d);
            <span class="pl-k">if</span> (it != tmp[i].<span class="pl-c1">begin</span>())
            {
                it--;
                ll now = *it + add[i];
                <span class="pl-k">if</span> (now &lt; c)
                {
                    <span class="pl-c1">cmax</span>(ans, now);
                }
            }
        }
        <span class="pl-k">if</span> (ans == -INF)
            <span class="pl-k">return</span> -<span class="pl-c1">1</span>;
        <span class="pl-k">return</span> ans;
    }
}
<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    cin &gt;&gt; n;
    len = <span class="pl-c1">sqrt</span>(n);
    ll cnt = <span class="pl-c1">get</span>(n);
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n) cin &gt;&gt; a[i];
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, cnt)
    {
        add[i] = <span class="pl-c1">0</span>;
        <span class="pl-c1">build</span>(i);
    }
    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        ll op, l, r, c;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;
        <span class="pl-k">if</span> (op == <span class="pl-c1">0</span>)
        {
            <span class="pl-c1">change</span>(l, r, c);
        }
        <span class="pl-k">else</span>
        {
            ll ans = <span class="pl-c1">query</span>(l, r, c);
            cout &lt;&lt; ans &lt;&lt; endl;
        }
    }
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    <span class="pl-c"><span class="pl-c">//</span> cin&gt;&gt;_;//如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>数列分块入门4</h2>
<h1>P13979 数列分块入门 4</h1>
<h2>题目背景</h2>
<p>洛谷的数列分块入门系列的测试数据范围和原题有不同。</p>
<h2>题目描述</h2>
<p>给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，区间求和。</p>
<h2>输入格式</h2>
<p>第一行输入一个数字 $n$。</p>
<p>第二行输入 $n$ 个数字，第 $i$ 个数字为 $a_i$，以空格隔开。</p>
<p>接下来输入 $n$ 行询问，每行输入四个数字 $\mathrm{opt}$、$l$、$r$、$c$，以空格隔开。</p>
<p>若 $\mathrm{opt} = 0$，表示将位于 $[l, r]$ 的之间的数字都加 $c$。</p>
<p>若 $\mathrm{opt} = 1$，表示询问位于 $[l, r]$ 的所有数字的和 $\bmod (c+1)$。你需要输出<strong>非负的余数值</strong>。</p>
<h2>输出格式</h2>
<p>对于每次询问，输出一行一个数字表示答案。</p>
<h2>输入输出样例 #1</h2>
<h3>输入 #1</h3>
<pre class="notranslate"><code class="notranslate">4
1 2 2 3
0 1 3 1
1 1 4 4
0 1 2 2
1 1 2 4
</code></pre>
<h3>输出 #1</h3>
<pre class="notranslate"><code class="notranslate">1
4
</code></pre>
<h2>说明/提示</h2>
<h3>子任务</h3>
<p>子任务 1（40 分）：$1 \leq n \leq 50000, -2^{31} \leq a_i,c \leq 2^{31}-1$。</p>
<p>子任务 2（60 分）：$1 \leq n \leq 300000, -2^{31} \leq a_i,c \leq 2^{31}-1$。</p>
<p>对于所有测试数据，满足 $1 \leq n \leq 300000, -2^{31} \leq a_i,c \leq 2^{31}-1$。$1 \leq l \leq r \leq n$。$\mathrm{opt} \in {0,1}, 1 \leq l \leq r\leq n$。每次操作后的 $a_i$ 满足 $-2^{31} \leq a_i \leq 2^{31}-1$。特别地，数据保证当 $\mathrm{opt}=1$ 时，$c\geq 0$。</p>
<blockquote>
<p>先吐槽一下vjudge的评测系统，太水了，我很多边界和细节都没有注意，给我一次过了，现在果断换上洛谷的题面和评测，第一次在Vjudge上写还真以为会了呢，结果一大堆细节没有处理好，真是会让人产生学会了的幻觉啊！！！<br>
代码：</p>
</blockquote>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c"><span class="pl-c">//</span> CJX__//</span>
<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll; <span class="pl-c"><span class="pl-c">//</span> 不开long long 见祖宗</span>
<span class="pl-k">typedef</span> <span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ull;
<span class="pl-k">typedef</span> __int128 <span class="pl-k">i128</span>;
<span class="pl-k">typedef</span> pair&lt;<span class="pl-k">int</span>, <span class="pl-k">int</span>&gt; PII;
<span class="pl-k">typedef</span> pair&lt;ll, ll&gt; PLL;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">int</span>&gt; vi;
<span class="pl-k">typedef</span> vector&lt;ll&gt; vll;
<span class="pl-k">typedef</span> vector&lt;<span class="pl-k">double</span>&gt; vd;
<span class="pl-k">typedef</span> vector&lt;PII&gt; vPII;
#<span class="pl-k">define</span> <span class="pl-en">IOS</span>                  \
    <span class="pl-en">ios::sync_with_stdio</span>(<span class="pl-c1">0</span>); \
    cin.tie(<span class="pl-c1">0</span>);              \
    cout.tie(<span class="pl-c1">0</span>);
#<span class="pl-k">define</span> <span class="pl-en">debug</span>(...) cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>[debug] <span class="pl-pds">"</span></span> #__VA_ARGS__ <span class="pl-s"><span class="pl-pds">"</span> = <span class="pl-pds">"</span></span> &lt;&lt; (__VA_ARGS__) &lt;&lt; endl;
#<span class="pl-k">define</span> <span class="pl-en">out</span>(<span class="pl-v">x</span>) cout &lt;&lt; ((x) ? <span class="pl-s"><span class="pl-pds">"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">"</span>NO<span class="pl-pds">"</span></span>) &lt;&lt; endl
#<span class="pl-k">define</span> <span class="pl-en">mod</span>(<span class="pl-v">x, P</span>) (((x) % (P) + (P)) % (P))
#<span class="pl-k">define</span> <span class="pl-en">endl</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>
#<span class="pl-k">define</span> <span class="pl-en">gcd</span> __gcd
#<span class="pl-k">define</span> <span class="pl-en">lc</span> p &lt;&lt; <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">rc</span> p &lt;&lt; <span class="pl-c1">1</span> | <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">INF</span> <span class="pl-c1">0x3f3f3f3f3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">inf</span> <span class="pl-c1">0x3f3f3f3f</span>
#<span class="pl-k">define</span> <span class="pl-en">fi</span> first
#<span class="pl-k">define</span> <span class="pl-en">se</span> second
#<span class="pl-k">define</span> <span class="pl-en">all</span>(<span class="pl-v">x</span>) x.begin(), x.end()
#<span class="pl-k">define</span> <span class="pl-en">lowbit</span>(<span class="pl-v">x</span>) ((x) &amp; (-x))
#<span class="pl-k">define</span> <span class="pl-en">rep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &lt;= n; i++)
#<span class="pl-k">define</span> <span class="pl-en">dep</span>(<span class="pl-v">i, x, n</span>) <span class="pl-k">for</span> (ll i = x; i &gt;= n; i--)
#<span class="pl-k">define</span> <span class="pl-en">mem</span>(<span class="pl-v">a, x</span>) memset(a, x, <span class="pl-k">sizeof</span> a)
<span class="pl-k">const</span> <span class="pl-k">double</span> eps = <span class="pl-c1">1e-5</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">3e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">550</span>, K = <span class="pl-c1">26</span>;
<span class="pl-k">const</span> ll MOD = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md3 = <span class="pl-c1">998244353</span>, Md7 = <span class="pl-c1">1e9</span> + <span class="pl-c1">7</span>, Md9 = <span class="pl-c1">1e9</span> + <span class="pl-c1">9</span>;
<span class="pl-k">const</span> ll base1 = <span class="pl-c1">131</span>, base2 = <span class="pl-c1">13331</span>;
<span class="pl-k">const</span> <span class="pl-k">int</span> dx[<span class="pl-c1">8</span>] = {-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>}, dy[<span class="pl-c1">8</span>] = {<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">1</span>};
<span class="pl-k">const</span> <span class="pl-k">int</span> ddx[<span class="pl-c1">8</span>] = {<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>}, ddy[<span class="pl-c1">8</span>] = {<span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, -<span class="pl-c1">2</span>, <span class="pl-c1">1</span>, -<span class="pl-c1">1</span>};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmin</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &lt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">bool</span> <span class="pl-en">cmax</span>(T &amp;a, <span class="pl-k">const</span> T &amp;b) { <span class="pl-k">return</span> b &gt; a ? a = b, <span class="pl-c1">1</span> : <span class="pl-c1">0</span>; }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">sort_range</span>(vector&lt;T&gt; &amp;v, <span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>() + l, v.<span class="pl-c1">begin</span>() + r + <span class="pl-c1">1</span>); }
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT1</span>
{
    <span class="pl-k">int</span> n;
    vector&lt;T&gt; tr;
    <span class="pl-en">BIT1</span>(<span class="pl-k">int</span> n) : n(n), tr(n + <span class="pl-c1">1</span>) {}
    <span class="pl-k">void</span> <span class="pl-en">add</span>(<span class="pl-k">int</span> x, T v)
    {
        <span class="pl-k">for</span> (; x &lt;= n; x += x &amp; -x)
            tr[x] += v;
    }
    T <span class="pl-en">sum</span>(<span class="pl-k">int</span> x)
    {
        T r = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (; x; x -= x &amp; -x)
            r += tr[x];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">range</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> <span class="pl-c1">sum</span>(r) - <span class="pl-c1">sum</span>(l - <span class="pl-c1">1</span>); }
};
<span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">struct</span> <span class="pl-en">BIT2</span>
{
    <span class="pl-k">int</span> n, m;
    vector&lt;vector&lt;T&gt;&gt; t1, t2, t3, t4;
    <span class="pl-en">BIT2</span>(<span class="pl-k">int</span> n_ = <span class="pl-c1">0</span>, <span class="pl-k">int</span> m_ = <span class="pl-c1">0</span>) { <span class="pl-c1">init</span>(n_, m_); }
    <span class="pl-k">void</span> <span class="pl-en">init</span>(<span class="pl-k">int</span> n_, <span class="pl-k">int</span> m_)
    {
        n = n_;
        m = m_;
        t1.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t2.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t3.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
        t4.<span class="pl-c1">assign</span>(n + <span class="pl-c1">1</span>, vector&lt;T&gt;(m + <span class="pl-c1">1</span>, T{}));
    }
    <span class="pl-k">void</span> <span class="pl-en">_add</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &lt;= n; i += i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &lt;= m; j += j &amp; -j)
            {
                t1[i][j] += v;
                t2[i][j] += v * x;
                t3[i][j] += v * y;
                t4[i][j] += v * x * y;
            }
    }
    <span class="pl-k">void</span> <span class="pl-en">rangeAdd</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2, <span class="pl-k">const</span> T &amp;v)
    {
        <span class="pl-c1">_add</span>(x1, y1, v);
        <span class="pl-c1">_add</span>(x1, y2 + <span class="pl-c1">1</span>, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y1, -v);
        <span class="pl-c1">_add</span>(x2 + <span class="pl-c1">1</span>, y2 + <span class="pl-c1">1</span>, v);
    }
    T <span class="pl-en">prefixSum</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y)
    {
        T r{};
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i = x; i &gt; <span class="pl-c1">0</span>; i -= i &amp; -i)
            <span class="pl-k">for</span> (<span class="pl-k">int</span> j = y; j &gt; <span class="pl-c1">0</span>; j -= j &amp; -j)
                r += t1[i][j] * (x + <span class="pl-c1">1</span>) * (y + <span class="pl-c1">1</span>) - t2[i][j] * (y + <span class="pl-c1">1</span>) - t3[i][j] * (x + <span class="pl-c1">1</span>) + t4[i][j];
        <span class="pl-k">return</span> r;
    }
    T <span class="pl-en">rangeSum</span>(<span class="pl-k">int</span> x1, <span class="pl-k">int</span> y1, <span class="pl-k">int</span> x2, <span class="pl-k">int</span> y2)
    {
        <span class="pl-k">if</span> (x1 &gt; x2 || y1 &gt; y2)
            <span class="pl-k">return</span> T{};
        <span class="pl-k">return</span> <span class="pl-c1">prefixSum</span>(x2, y2) - <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y2) - <span class="pl-c1">prefixSum</span>(x2, y1 - <span class="pl-c1">1</span>) + <span class="pl-c1">prefixSum</span>(x1 - <span class="pl-c1">1</span>, y1 - <span class="pl-c1">1</span>);
    }
};
<span class="pl-k">struct</span> <span class="pl-en">Random</span>
{
    mt19937_64 rng;
    <span class="pl-en">Random</span>() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull <span class="pl-en">rand_ull</span>(ull max_val = -<span class="pl-c1">1</span>) { <span class="pl-k">return</span> <span class="pl-c1">rng</span>() % (max_val + <span class="pl-c1">1</span>); }
    ll <span class="pl-en">rand_ll</span>(ll l, ll r) { <span class="pl-k">return</span> uniform_int_distribution&lt;ll&gt;(l, r)(rng); }
    <span class="pl-k">int</span> <span class="pl-en">rand_int</span>(<span class="pl-k">int</span> l, <span class="pl-k">int</span> r) { <span class="pl-k">return</span> uniform_int_distribution&lt;<span class="pl-k">int</span>&gt;(l, r)(rng); }
    <span class="pl-k">double</span> <span class="pl-en">rand_db</span>(<span class="pl-k">double</span> l, <span class="pl-k">double</span> r) { <span class="pl-k">return</span> uniform_real_distribution&lt;<span class="pl-k">double</span>&gt;(l, r)(rng); }
    <span class="pl-k">bool</span> <span class="pl-en">rand_bool</span>(<span class="pl-k">double</span> p = <span class="pl-c1">0.5</span>) { <span class="pl-k">return</span> <span class="pl-c1">bernoulli_distribution</span>(p)(rng); }
    <span class="pl-k">template </span>&lt;<span class="pl-k">typename</span> T&gt;
    <span class="pl-k">void</span> <span class="pl-en">shuffle</span>(vector&lt;T&gt; &amp;v) { <span class="pl-c1">std::shuffle</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), rng); }
};
ll <span class="pl-en">qmi</span>(ll a, ll b, ll p)
{
    ll res = <span class="pl-c1">1</span> % p;
    a %= p;
    <span class="pl-k">while</span> (b)
    {
        <span class="pl-k">if</span> (b &amp; <span class="pl-c1">1</span>)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> res;
}
<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c"></span>
<span class="pl-c"><span class="pl-c">*/</span></span>

ll n, len;
ll a[N], add[M], sum[M];

ll <span class="pl-en">get</span>(ll i)
{
    <span class="pl-k">return</span> (i - <span class="pl-c1">1</span>) / len + <span class="pl-c1">1</span>;
}

<span class="pl-k">void</span> <span class="pl-en">modify</span>(ll l, ll r, ll d)
{
    ll bl = <span class="pl-c1">get</span>(l), br = <span class="pl-c1">get</span>(r);
    <span class="pl-k">if</span> (bl == br)
    {
        <span class="pl-c1">rep</span>(i, l, r)
        {
            a[i] += d;
            sum[bl] += d;
        }
    }
    <span class="pl-k">else</span>
    {

        <span class="pl-k">for</span> (ll i = l; i &lt;= <span class="pl-c1">min</span>(bl * len, n); i++)
        {
            a[i] += d;
            sum[bl] += d;
        }

        <span class="pl-k">for</span> (ll i = (br - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>; i &lt;= r; i++)
        {
            a[i] += d;
            sum[br] += d;
        }

        <span class="pl-k">for</span> (ll i = bl + <span class="pl-c1">1</span>; i &lt; br; i++)
        {
            add[i] += d;
        }
    }
}

ll <span class="pl-en">query</span>(ll l, ll r, ll c)
{
    ll m = c + <span class="pl-c1">1</span>;
    ll tot = <span class="pl-c1">0</span>;
    ll bl = <span class="pl-c1">get</span>(l), br = <span class="pl-c1">get</span>(r);

    <span class="pl-k">if</span> (bl == br)
    {
        <span class="pl-c1">rep</span>(i, l, r)
        {
            tot = (tot + a[i] + add[bl]);
        }
    }
    <span class="pl-k">else</span>
    {

        <span class="pl-k">for</span> (ll i = l; i &lt;= <span class="pl-c1">min</span>(bl * len, n); i++)
        {
            tot = (tot + a[i] + add[bl]);
        }

        <span class="pl-k">for</span> (ll i = (br - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>; i &lt;= r; i++)
        {
            tot = (tot + a[i] + add[br]);
        }

        <span class="pl-k">for</span> (ll i = bl + <span class="pl-c1">1</span>; i &lt; br; i++)
        {

            ll st = (i - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>;
            ll ed = <span class="pl-c1">min</span>(i * len, n);
            ll far = ed - st + <span class="pl-c1">1</span>;
            tot += sum[i] + add[i] * far;
        }
    }

    <span class="pl-k">return</span> <span class="pl-c1">mod</span>(tot, m);
}

<span class="pl-k">void</span> <span class="pl-en">solve</span>()
{
    cin &gt;&gt; n;
    len = <span class="pl-c1">sqrt</span>(n);

    <span class="pl-c"><span class="pl-c">//</span> mem(add, 0);</span>
    <span class="pl-c"><span class="pl-c">//</span> mem(sum, 0);</span>

    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        cin &gt;&gt; a[i];
        sum[<span class="pl-c1">get</span>(i)] += a[i];
    }

    <span class="pl-c1">rep</span>(i, <span class="pl-c1">1</span>, n)
    {
        ll op, l, r, c;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;
        <span class="pl-k">if</span> (op == <span class="pl-c1">0</span>)
        {
            <span class="pl-c1">modify</span>(l, r, c);
        }
        <span class="pl-k">else</span>
        {
            ll ans = <span class="pl-c1">query</span>(l, r, c);
            cout &lt;&lt; ans &lt;&lt; endl;
        }
    }
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    IOS;

    <span class="pl-k">int</span> _ = <span class="pl-c1">1</span>;
    <span class="pl-c"><span class="pl-c">//</span> cin&gt;&gt;_;//如果是多组数据</span>
    <span class="pl-k">while</span> (_--)
    {
        <span class="pl-c1">solve</span>();
    }
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>数列分块入门 5</h2>
<h1>P13980 数列分块入门 5</h1>
<h2>题目背景</h2>
<p>洛谷的数列分块入门系列的测试数据范围和原题有不同。</p>
<h2>题目描述</h2>
<p>给出一个长为 $n$ 的数列 $a_1 \ldots a_n$，以及 $n$ 个操作，操作涉及区间开方，区间求和。</p>
<h2>输入格式</h2>
<p>第一行输入一个数字 $n$。</p>
<p>第二行输入 $n$ 个数字，第 $i$ 个数字为 $a_i$，以空格隔开。</p>
<p>接下来输入 $n$ 行询问，每行输入三个数字 $\mathrm{opt}, l, r$，以空格隔开。</p>
<p>若 $\mathrm{opt} = 0$，表示将位于 $[l, r]$ 的之间的数字都开方。对于区间中每个 $a_i(l\le i\le r),: a_i \leftarrow \left\lfloor \sqrt{a_i}\right\rfloor$</p>
<p>若 $\mathrm{opt} = 1$，表示询问位于 $[l, r]$ 的所有数字的和。</p>
<h2>输出格式</h2>
<p>对于每次询问，输出一行一个数字表示答案。</p>
<h2>输入输出样例 #1</h2>
<h3>输入 #1</h3>
<pre class="notranslate"><code class="notranslate">4
1 2 2 3
0 1 3
1 1 4
0 1 2
1 1 2
</code></pre>
<h3>输出 #1</h3>
<pre class="notranslate"><code class="notranslate">6
2
</code></pre>
<h2>说明/提示</h2>
<h3>子任务</h3>
<p>子任务 1（40 分）：$1 \leq n \leq 50000, 0 \leq a_i,\mathrm{ans} \leq 2^{31}-1$。</p>
<p>子任务 2（60 分）：$1 \leq n \leq 300000, 0 \leq a_i \leq 2^{31}-1$，$0\leq \mathrm{ans}\leq 2^{63}-1$。</p>
<p>对于所有测试数据，满足 $1 \leq n \leq 300000, 0 \leq a_i \leq 2^{31}-1$，$0\leq \mathrm{ans} \leq 2^{63}-1$。$1 \leq l \leq r \leq n$。$\mathrm{opt} \in {0,1}, 1 \leq l \leq r\leq n$。每次操作后的 $a_i$ 满足 $0 \leq a_i \leq 2^{31}-1$。</p>
<p>代码：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>bits/stdc++.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>

<span class="pl-k">typedef</span> <span class="pl-k">long</span> <span class="pl-k">long</span> ll;
<span class="pl-k">const</span> <span class="pl-k">int</span> N = <span class="pl-c1">3e5</span> + <span class="pl-c1">10</span>, M = <span class="pl-c1">550</span>;

ll n, len;
ll a[N], sum[M];  <span class="pl-c"><span class="pl-c">//</span> sum记录每个块的和</span>
<span class="pl-k">bool</span> flag[M];     <span class="pl-c"><span class="pl-c">//</span> flag标记块是否全为0或1（开方后不再变化）</span>

ll <span class="pl-en">get</span>(ll i) {
    <span class="pl-k">return</span> (i - <span class="pl-c1">1</span>) / len + <span class="pl-c1">1</span>;
}

<span class="pl-k">void</span> <span class="pl-en">build</span>(ll block) {
    ll st = (block - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>;
    ll ed = <span class="pl-c1">min</span>(block * len, n);
    sum[block] = <span class="pl-c1">0</span>;
    flag[block] = <span class="pl-c1">true</span>;  
    
    <span class="pl-k">for</span> (ll i = st; i &lt;= ed; i++) {
        sum[block] += a[i];
        <span class="pl-k">if</span> (a[i] &gt; <span class="pl-c1">1</span>) {
            flag[block] = <span class="pl-c1">false</span>;  
        }
    }
}


<span class="pl-k">void</span> <span class="pl-en">sqrt_range</span>(ll l, ll r) {
    ll bl = <span class="pl-c1">get</span>(l), br = <span class="pl-c1">get</span>(r);
    
    <span class="pl-k">if</span> (bl == br) {
        <span class="pl-k">if</span> (flag[bl]) <span class="pl-k">return</span>; 
        
        <span class="pl-k">for</span> (ll i = l; i &lt;= r; i++) {
            ll old = a[i];
            a[i] = (ll)<span class="pl-c1">sqrt</span>(a[i]);  
            sum[bl] += (a[i] - old);
        }
        
        flag[bl] = <span class="pl-c1">true</span>;
        ll st = (bl - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>;
        ll ed = <span class="pl-c1">min</span>(bl * len, n);
        <span class="pl-k">for</span> (ll i = st; i &lt;= ed; i++) {
            <span class="pl-k">if</span> (a[i] &gt; <span class="pl-c1">1</span>) {
                flag[bl] = <span class="pl-c1">false</span>;
                <span class="pl-k">break</span>;
            }
        }
    } <span class="pl-k">else</span> {
       
        <span class="pl-k">if</span> (!flag[bl]) {
            <span class="pl-k">for</span> (ll i = l; i &lt;= bl * len; i++) {
                ll old = a[i];
                a[i] = (ll)<span class="pl-c1">sqrt</span>(a[i]);
                sum[bl] += (a[i] - old);
            }
           
            flag[bl] = <span class="pl-c1">true</span>;
            ll st = (bl - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>;
            ll ed = bl * len;
            <span class="pl-k">for</span> (ll i = st; i &lt;= ed; i++) {
                <span class="pl-k">if</span> (a[i] &gt; <span class="pl-c1">1</span>) {
                    flag[bl] = <span class="pl-c1">false</span>;
                    <span class="pl-k">break</span>;
                }
            }
        }
        
    
        <span class="pl-k">if</span> (!flag[br]) {
            <span class="pl-k">for</span> (ll i = (br - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>; i &lt;= r; i++) {
                ll old = a[i];
                a[i] = (ll)<span class="pl-c1">sqrt</span>(a[i]);
                sum[br] += (a[i] - old);
            }
          
            flag[br] = <span class="pl-c1">true</span>;
            ll st = (br - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>;
            ll ed = <span class="pl-c1">min</span>(br * len, n);
            <span class="pl-k">for</span> (ll i = st; i &lt;= ed; i++) {
                <span class="pl-k">if</span> (a[i] &gt; <span class="pl-c1">1</span>) {
                    flag[br] = <span class="pl-c1">false</span>;
                    <span class="pl-k">break</span>;
                }
            }
        }
        
       
        <span class="pl-k">for</span> (ll i = bl + <span class="pl-c1">1</span>; i &lt;= br - <span class="pl-c1">1</span>; i++) {
            <span class="pl-k">if</span> (flag[i]) <span class="pl-k">continue</span>; 
            
            flag[i] = <span class="pl-c1">true</span>;  
            ll st = (i - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>;
            ll ed = <span class="pl-c1">min</span>(i * len, n);
            
            <span class="pl-k">for</span> (ll j = st; j &lt;= ed; j++) {
                ll old = a[j];
                a[j] = (ll)<span class="pl-c1">sqrt</span>(a[j]);
                sum[i] += (a[j] - old);
                <span class="pl-k">if</span> (a[j] &gt; <span class="pl-c1">1</span>) {
                    flag[i] = <span class="pl-c1">false</span>;  
                }
            }
        }
    }
}


ll <span class="pl-en">query_sum</span>(ll l, ll r) {
    ll bl = <span class="pl-c1">get</span>(l), br = <span class="pl-c1">get</span>(r);
    ll tot = <span class="pl-c1">0</span>;
    
    <span class="pl-k">if</span> (bl == br) {
        <span class="pl-k">for</span> (ll i = l; i &lt;= r; i++) {
            tot += a[i];
        }
    } <span class="pl-k">else</span> {
       
        <span class="pl-k">for</span> (ll i = l; i &lt;= bl * len; i++) {
            tot += a[i];
        }
        
        <span class="pl-k">for</span> (ll i = (br - <span class="pl-c1">1</span>) * len + <span class="pl-c1">1</span>; i &lt;= r; i++) {
            tot += a[i];
        }
       
        <span class="pl-k">for</span> (ll i = bl + <span class="pl-c1">1</span>; i &lt;= br - <span class="pl-c1">1</span>; i++) {
            tot += sum[i];
        }
    }
    <span class="pl-k">return</span> tot;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    <span class="pl-c1">ios::sync_with_stdio</span>(<span class="pl-c1">false</span>);
    cin.<span class="pl-c1">tie</span>(<span class="pl-c1">0</span>);
    
    cin &gt;&gt; n;
    len = <span class="pl-c1">sqrt</span>(n);
    ll blocks = <span class="pl-c1">get</span>(n);
    
    <span class="pl-k">for</span> (ll i = <span class="pl-c1">1</span>; i &lt;= n; i++) {
        cin &gt;&gt; a[i];
    }
    

    <span class="pl-k">for</span> (ll i = <span class="pl-c1">1</span>; i &lt;= blocks; i++) {
        <span class="pl-c1">build</span>(i);
    }
    
    <span class="pl-k">for</span> (ll i = <span class="pl-c1">1</span>; i &lt;= n; i++) {
        ll op, l, r;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r ;
        <span class="pl-k">if</span> (op == <span class="pl-c1">0</span>) {
         
            <span class="pl-c1">sqrt_range</span>(l, r);
        } <span class="pl-k">else</span> {
        
            ll result = <span class="pl-c1">query_sum</span>(l, r);
            cout &lt;&lt; result &lt;&lt; endl;
        }
    }
    
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://zhezhi198.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","zhezhi198/zhezhi198.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
