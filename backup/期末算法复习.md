>期末考察范围:暴力，贪心，分治，递归，dp，搜索，其他....
暴力：编程 枚举
贪心:编程
分治/递归:编程，简答
dp:编程 0/1背包简化
搜索:简答，编程
其他：问答
 ## 注意:务必不要背模板，特别是不要背我的模板，务必要理解，可以每天晚上花上40分钟试一下，以下所有仅供思路和理解上的参考。
>DP：
先说说01背包:
[01背包模板题](https://www.acwing.com/problem/content/description/2/)
01背包是动态规划中最基础也是最重要的模型。本文记录从朴素的二维 DP 到空间优化后的一维 DP 的推导过程。

## 问题描述

给定 $N$ 个物品，第 $i$ 个物品的体积为 $v[i]$，价值为 $w[i]$。
有一个容量为 $M$ 的背包。每件物品**只能选择一次**，求在不超过背包容量的前提下，能装入的最大总价值。

## 1. 朴素解法 (二维 DP)

### 状态定义
定义 $f[i][j]$ 表示：**只看前 $i$ 个物品，在背包容量为 $j$ 的情况下，能获得的最大价值**。

### 状态转移方程
对于第 $i$ 个物品，我们只有两个选择：
1.  **不选**：价值等于前 $i-1$ 个物品在容量 $j$ 下的价值。即 $f[i-1][j]$。
2.  **选**：前提是 $j \ge v[i]$。价值等于前 $i-1$ 个物品在容量 $j-v[i]$ 下的价值加上当前物品价值 $w[i]$。

转移方程如下：
$$f[i][j] = \max(f[i-1][j], \ f[i-1][j-v[i]] + w[i])$$

### 核心代码
```cpp
// 朴素二维版本
cin >> n >> m;
rep(i, 1, n) cin >> v[i] >> w[i];

rep(i, 1, n) // 枚举物品
{
    rep(j, 0, m) // 枚举容积
    {
        f[i][j] = f[i - 1][j]; // 不选
        if (j >= v[i])         // 选（前提是装得下）
            f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
    }
}
cout << f[n][m] << endl;
```
## 空间优化：从二维到一维

### 1. 滚动数组的思路
观察二维状态转移方程：

$$
f[i][j] = \max(f[i-1][j], \ f[i-1][j-v[i]] + w[i])
$$

我们发现，计算第 $i$ 层物品的状态时，只依赖于第 $i-1$ 层（上一层）的状态。更早的 $i-2$ 层数据其实已经没用了。
这就好比盖楼，盖第 10 层的时候，只需要基于第 9 层，跟第 1 层没关系。

所以，我们可以把二维数组 $f[i][j]$ 压缩成一维数组 $f[j]$。
新方程：

$$
f[j] = \max(f[j], \ f[j-v[i]] + w[i])
$$

### 2. 为什么必须倒序遍历？（核心）
将状态压缩为一维后，枚举背包容量 $j$ 的顺序变得至关重要。

* **如果正序遍历 (`rep`)**：
    当我们计算 $f[j]$ 时，需要用到 $f[j-v[i]]$。
    因为 $j-v[i] < j$，在从左往右遍历时，$f[j-v[i]]$ 已经被**当前这层（第 $i$ 个物品）**更新过了。
    这就意味着：我们在通过“已经放入第 $i$ 个物品”的状态来更新 $f[j]$，导致一件物品被放入多次。这是**完全背包**的做法，不符合 01 背包“每种只有一件”的限制。

* **如果倒序遍历 (`dep`)**：
    当我们计算 $f[j]$ 时，由于是从右往左更新，$f[j-v[i]]$ 还没有被当前层访问到。
    此时的 $f[j-v[i]]$ 存储的依然是**上一层（第 $i-1$ 个物品）**的状态。
    这完美符合了 $f[i][j] = \max(f[i-1][j], \dots)$ 的定义。

### 3. 优化后代码实现
利用宏定义 `dep` (for loop downto) 来实现倒序：

```cpp
// 空间优化核心代码
// v[i]: 体积, w[i]: 价值, s: 背包总容量
vll f(s + 1, 0); 

rep(i, 1, n) // 第一层循环：枚举物品
{
    // 第二层循环：必须倒序！从背包容量 s 遍历到 v[i]
    dep(j, s, v[i])
    {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
}
cout << f[s] << endl;
```
此外01背包有时候还有这样的问题:
1.不要求背包装满能够获得的最大价值。
2.背包恰好装满时能够获得的最大价值
## 进阶：背包恰好装满 vs 不必装满

在 01 背包的变种题目中，我们经常会遇到两种不同的问法：
1.  **不要求**背包装满，求能获得的最大价值（标准 01 背包）。
2.  **要求**背包**恰好装满**，求能获得的最大价值。若无法装满，则输出 0 或无解。

例题参考：[牛客网 - 01背包的一些特定的情况](https://ac.nowcoder.com/acm/problem/226514)

### 初始化决定状态
这两种问法的区别，仅仅在于 **DP 数组的初始化**。

#### 1. 不要求装满
**初始化：** `f` 数组全部初始化为 **0**。
**原理：**
如果背包不要求装满，那么“容量为 $j$ 的背包什么都不装”也是一种合法状态，其价值为 0。
所以在转移过程中，任何容量起步都是合法的。

#### 2. 要求恰好装满
**初始化：** `f[0] = 0`，其余 `f[1...m]` 全部初始化为 **-INF**（负无穷）。
**原理：**
* **合法起点**：只有容量为 0 的背包，在什么都不装的情况下是“恰好装满”的（被 0 体积的东西填满），价值为 0。所以 `f[0] = 0`。
* **非法起点**：对于 $j > 0$，如果不装任何东西，是不可能“恰好装满”容量 $j$ 的。所以这些状态在初始时是非法的，用 `-INF` 标记。
* **状态转移**：在 DP 过程中，`max` 操作会保证我们就只能从合法状态（即从 `f[0]` 推导出来的路径）进行转移。如果一个状态无法由 `f[0]` 经过若干物品推导而来，它的值会依然是一个很小的负数。

### 代码实现
以下代码同时展示了这两种情况的处理。
* `dp1`: 对应不要求装满。
* `dp2`: 对应要求恰好装满。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll; 
typedef vector<ll> vll;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl '\n'
#define rep(i, x, n) for (ll i = x; i <= n; i++)
#define dep(i, x, n) for (ll i = x; i >= n; i--)
#define INF 0x3f3f3f3f3f3f3f3f

const int N = 1e3 + 10;
ll n, m;
ll v[N], w[N];

void solve()
{
    cin >> n >> m;
    rep(i, 1, n) cin >> v[i] >> w[i];
    
    // dp1: 不要求装满，全部初始化为 0
    vll dp1(m + 1, 0);
    
    // dp2: 要求恰好装满，初始化为 -INF，只有 dp2[0] 为 0
    vll dp2(m + 1, -INF);
    dp2[0] = 0;

    rep(i, 1, n)
    {
        dep(j, m, v[i])
        {
            // 方案 1 转移
            dp1[j] = max(dp1[j], dp1[j - v[i]] + w[i]);
            
            // 方案 2 转移 (逻辑完全一样)
            dp2[j] = max(dp2[j], dp2[j - v[i]] + w[i]);
        }
    }

    // 输出方案 1
    cout << dp1[m] << endl;

    // 输出方案 2
    // 注意：如果 dp2[m] 依然是负数（说明由 -INF 转移而来），则无解
    if (dp2[m] < 0)
    {
        cout << 0 << endl;
    }
    else
    {
        cout << dp2[m] << endl;
    }
}

int main()
{
    IOS;
    int _ = 1;
    while (_--)
    {
        solve();
    }
    return 0;
}
```
>由于复习时间和考的范围有限其他的背包问题就先不写了,想清楚上面的问题至少对01背包问题有了一个深刻的认识。

## 然后我们再说说递归
>经典的搜索任务:
1.子集枚举
2.排列枚举
3.组合枚举

描述:前两个在解空间中可用解空间树描述，前一个称为子集树，共有2^n个叶节点，后一个称为排列树，叶节点共有n!个。

我在luogu上找了一些典型的例题，除此之外有时间还可以针对的写写对应的题单。
我们以 Luogu P1706 全排列问题为例，深入理解DFS和回溯的思想。

## 题目描述
[P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)
按照字典序输出自然数 $1$ 到 $n$ 所有不重复的排列。

## 1. 算法核心：搜索树与回溯

### 排列树（Permutation Tree）
我们可以把全排列的过程想象成“填空位”。
假设有 $n$ 个空盒子，我们需要把 $1 \dots n$ 这 $n$ 个数字填进去。
1.  **第一层递归**：站在第 1 个盒子前，我们有 $1 \dots n$ 种选择。
2.  **第二层递归**：站在第 2 个盒子前，我们不能选刚才已经用过的数字，只能选剩下的。
3.  **终止条件**：当我们走到第 $n+1$ 个盒子时，说明前 $n$ 个都已经填满，此时输出结果。



### 关键概念：状态数组 `st[]`
在递归过程中，我们需要知道哪些数字由于被前面的盒子占用了而**不能选**。
因此引入一个 bool 数组 `st[i]`（state）：
* `st[i] == true`: 数字 $i$ 已经被使用了。
* `st[i] == false`: 数字 $i$ 目前可用。

### 核心步骤：回溯 
这是新手最容易晕的地方。当我们填完一种排列（比如 `1 2 3`），需要退回到上一步（第 2 个盒子），把 `3` 拿出来，尝试填入其他数字。
拿出来”这个动作，就是回溯（恢复现场）。

如果不把 `st[3]` 重新设为 `false`，程序会以为 `3` 还在盒子里，导致后续的排列无法再次使用 `3`。

## 2. 代码实现细节

我们在 `dfs(x)` 函数中维护三个逻辑：
1.  **边界判断**：如果 `x > n`，说明已经填完了，打印并**返回**。
2.  **枚举选择**：从小到大尝试 $1 \dots n$ 每个数字。
3.  **分支与回溯**：
    * 如果数字 `i` 没用过 $\rightarrow$ 标记 `st[i]=true` $\rightarrow$ 递归 `dfs(x+1)`。
    * 递归回来后 $\rightarrow$ **恢复现场** `st[i]=false`。

## 3. 完整 AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl '\n'

int n;
int arr[15];    // 存储当前的排列结果
bool st[15];    // 状态数组，记录数字是否被使用

// x 表示当前正在枚举第几个位置
void dfs(int x) {
    // 1. 截止条件：如果位置 x 超过了 n，说明 1~n 都填好了
    if (x > n) {
        for (int i = 1; i <= n; i++) {
            // 题目要求保留 5 个场宽
            printf("%5d", arr[i]);
        }
        printf("\n");
        return; // 非常重要！必须返回，否则会越界继续执行
    }

    // 2. 枚举当前位置 x 可以填入的数字 (1 到 n)
    for (int i = 1; i <= n; i++) {
        // 如果数字 i 没有被使用过
        if (!st[i]) {
            
            // 2.1 修改状态（占位）
            arr[x] = i;      // 把 i 填入第 x 个坑
            st[i] = true;    // 标记 i 已经被用过了

            // 2.2 递归到下一层
            dfs(x + 1);

            // 2.3 回溯（恢复现场）
            // 这一步至关重要：从下一层回来后，要把 i 拿出来，
            // 标记为未使用，这样循环到下一次或者回退时才能再次使用 i
            arr[x] = 0;      // (可选) 实际上会被覆盖，不写也没事
            st[i] = false;   // 核心：解除标记
        }
    }
}

void solve() {
    cin >> n;
    dfs(1); // 从第 1 个位置开始搜索
}

int main() {
    // 由于使用了 printf，混合 cin/cout 时最好不要关闭同步流，或者只用 C 风格 IO
    // 这里为了题目要求的格式化输出，核心部分使用了 printf
    int _ = 1;
    while (_--) {
        solve();
    }
    return 0;
}
```
# 递归与搜索：从全排列到组合输出

在上一篇文章中，我们通过 **[P1706 全排列]** 学习了利用 `st[]` 标记数组来实现全排列的搜索。
今天我们来看看它的兄弟问题：**[P1157 组合的输出]**。

## 题目描述
[P1157 组合的输出](https://www.luogu.com.cn/problem/P1157)

从 $1 \sim n$ 这 $n$ 个自然数中，任取 $r$ 个数（$r \le n$），输出所有可能的组合。
要求：每个组合中的元素按**从小到大**的顺序排列，所有组合按**字典序**输出。

例如 $n=5, r=3$，输出：
`1 2 3`, `1 2 4` ... `3 4 5`

## 1. 组合 vs 排列：核心区别

在写代码之前，必须搞清楚“组合”和“排列”在搜索树上的区别：

* **全排列 **：顺序重要。`1 2 3` 和 `3 2 1` 是两个不同的方案。
    * **策略**：每次都从 $1$ 扫到 $n$，只要没用过（`!st[i]`）就能选。
* **组合 **：顺序不重要。`1 2 3` 和 `3 2 1` 是同一个组合。
    * **策略**：为了不重复计算，我们人为规定**“必须按从小到大的顺序选”**。
    * 比如：选了 `2` 之后，下一个数只能选 `3, 4, 5...`，绝对不能回头选 `1`。



### 关键参数：`start`
为了实现“不回头”，我们在 DFS 函数中增加一个参数 `start`，表示**当前这个空位，只能从 `start` 开始枚举**。

## 2. 代码实现细节

### 函数定义 `dfs(x, start)`
* `x`: 当前正在填第几个坑（一共要填 $r$ 个）。
* `start`: 当前这个坑，数字枚举的**起始值**。

### 递归逻辑
1.  **截止条件**：`x > r`，说明 $r$ 个坑填满了，输出并返回。
2.  **枚举选择**：循环 `i` 从 `start` 到 `n`。
3.  **递归下一步**：`dfs(x + 1, i + 1)`。
    * **重点**：下一个坑必须比当前选的 `i` 还要大，所以是 `i + 1`，而不是 `start + 1`。

## 3. 完整 AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl '\n'

int n, r; // n选r
int arr[25]; // 存储当前的组合

// x: 当前枚举到了第几个位置 (1..r)
// start: 当前位置只能填 >= start 的数字
void dfs(int x, int start)
{
    // 1. 截止条件：选够了 r 个数
    if (x > r)
    {
        for (int i = 1; i <= r; i++)
        {
            printf("%3d", arr[i]); // 题目要求3个场宽
        }
        cout << endl;
        return;
    }

    // 2. 枚举当前位置能填的数
    // 只能从 start 开始填，保证单调递增，从而保证是组合而不是排列
    for (int i = start; i <= n; i++)
    {
        arr[x] = i; // 填入数字
        
        // 3. 递归下一层
        // 下一个位置必须从 i+1 开始填
        // 错误示范：dfs(x + 1, start + 1) -> 会导致重复或非递增
        dfs(x + 1, i + 1); 
        
        arr[x] = 0; // 回溯（其实不写也行，会被覆盖）
    }
}

void solve()
{
    cin >> n >> r;
    // 从第 1 个位置开始填，数字最小从 1 开始
    dfs(1, 1);
}

int main()
{
    // IOS; 
    // 注意：混用 printf 和 cout 时建议不要关同步，或者统一用一种 IO
    int _ = 1;
    while (_--)
    {
        solve();
    }
    return 0;
}
```

# 递归与搜索：指数型枚举（子集选择）

在之前的文章中，我们攻克了 **[P1706 全排列]**（$N!$）和 **[P1157 组合输出]**（$C_n^r$）。
今天我们来解决搜索算法中的第三块拼图：**[B3622 枚举子集]**。

## 题目描述
[B3622 枚举子集](https://www.luogu.com.cn/problem/B3622)

今有 $n$ 位同学，可以从中选出任意名同学参加合唱。请输出所有可能的选择方案。
每一名同学的状态用字符表示：
* `Y`：参加
* `N`：不参加

**要求**：以字典序输出答案。

例如 $n=3$，输出：
`NNN`, `NNY`, `NYN` ... `YYY`

## 1. 指数型枚举 vs 排列组合

在写代码之前，我们要搞清楚这道题和之前两道题在**决策树**上的本质区别：

* **全排列/组合**：是“填坑”模型。我们要考虑的是“当前这个坑填哪个数字”。
* **指数型枚举 (子集)**：是“开关”模型。
    * 我们不需要去选数字，而是要遍历这 $n$ 位同学。
    * **策略**：对于每一位同学，我们只有 **2 种选择**——**选 (Y)** 或者 **不选 (N)**。
    * 这种结构对应的是一棵**二叉树**，总方案数是 $2^n$。



### 关键逻辑：字典序
题目要求字典序输出。在 ASCII 码中，`'N'` (78) 小于 `'Y'` (89)。
为了满足字典序，我们在递归决策时，必须严格遵守顺序：
**先尝试 `N` (不选) $\to$ 再尝试 `Y` (选)**。

## 2. 代码实现细节

### 状态记录 `string ans`
与全排列使用 `arr[]` 数组不同，这里我们用一个字符串 `string ans` 来模拟**栈**结构，记录当前路径上的选择。

### 递归逻辑 `dfs(x)`
* `x`：表示当前正在做第 `x` 位同学的决定。
* **截止条件**：`x > n`，说明 $n$ 位同学的决定都做完了，输出 `ans` 并返回。
* **枚举选择**：
    1.  `ans += 'N'` (入栈) $\to$ `dfs(x+1)` $\to$ `ans.pop_back()` (回溯)
    2.  `ans += 'Y'` (入栈) $\to$ `dfs(x+1)` $\to$ `ans.pop_back()` (回溯)

为了代码简洁，我们可以用一个字符数组 `op[2] = {'N', 'Y'}` 来循环枚举。

## 3. 完整 AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
// CJX__//
typedef long long ll; 
#define endl '\n'

// 题目参数
ll n;  
// 字典序 N < Y，所以 N 放前面(对应索引0)，Y 放后面(对应索引1)
char op[2]={'N','Y'};
string ans; // 记录当前的决策路径 (充当栈)

// x 表示当前正在做第 x 个人的决定
void dfs(int x){
    // 1. 截止条件：已经做完 n 个人的决定了
    if(x > n){
        cout << ans << endl;
        return ;
    }

    // 2. 枚举当前人的两种状态：0(N) 和 1(Y)
    for(int i = 0; i <= 1; i++){
        ans += op[i];    // 1. 做出选择 (入栈)
        
        dfs(x + 1);      // 2. 递归下一层 (处理下一个人)
        
        ans.pop_back();  // 3. 回溯 (出栈，恢复现场)
    }
}       

void solve()
{
    cin >> n;
    dfs(1); // 从第 1 个人开始
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    
    int t = 1;
    while (t--)
    {
        solve();
    }
    return 0;
}
```
>DFS剪枝的那些要具体问题具体分析，以上的题目都是最基础最经典的三种例题，DFS的路道阻且长，还希望多加练习。
[给出暴力枚举的递归题单：](https://www.luogu.com.cn/training/108#problems)

分治的话晚些补充，先吃饭去了。其实分治方面的题目，之前能用分治写的基本没用分治写，分治方面其实还是很欠缺的。

