[点这里进入比赛界面](https://atcoder.jp/contests/abc430)

### C - Truck Driver
>核心问题分析


题目的要求是统计所有满足以下两个条件的子串 (l, r)：
1.a 的数量 >= A
2.b 的数量 < B

> 思路:
问题要求统计所有满足两个条件的子串：1. 'a'的数量 ≥ A；2. 'b'的数量 < B。
面对 N 高达 3×10⁵ 的数据规模， O(N²) 的暴力枚举所有 (l, r) 区间显然会超时。题目的特点是，当我们固定一个左端点 i 并向右移动右端点 j 时，子串中 a 和 b 的数量都是单调增加的。这种单调性是使用 滑动窗口（或多指针） 算法来优化的关键信号。

传统双指针的困境与三指针的引入
>传统的双指针 (l, r) 通常用于维护一个 同时满足所有条件 的“有效窗口”。但在这道题里，两个条件的方向不同：一个是“大于等于”（希望窗口更大），另一个是“小于”（希望窗口更小）。这导致对于一个固定的起点 i，合法的终点 j 不是一个点，而是一个连续的区间。

>让我们把这个合法终点区间称为 [j_min, j_max]：
*ja是第一个满足[i,j_min]中a的数量>=A的位置。
*jb是最后一个满足[i,j_max]中b的数量<B的位置。
只要我们为每个起点 i 找到这两个边界，那么对于这个 i，就有 max(0, j_max- j_min+1)个合法的子串。

这自然而然地引出了三指针解法：
>i 指针 (起点指针): 在主循环中遍历，代表我们正在考察的子串的起点。
l 指针 (下界指针): 它的任务是为当前的 i 找到 j_min。我们向右移动 ja，直到窗口 [i, ja-1] 首次满足 a 的数量 ≥ A。由于单调性，当 i 右移时，ja 无需回退，只需从当前位置继续右移即可。
r 指针 (上界指针): 它的任务是为当前的 i 找到 j_max。我们向右移动 jb，直到窗口 [i, jb-1] 恰好满足 b 的数量 < B，而窗口 [i, jb] 将要不满足条件。同样，jb 也无需回退。



为什么是三个指针，而不是两个？
>因为传统双指针旨在寻找一个“最优解点”，而本题需要寻找一个“最优解区间”。一个 left 指针和 一个 right 指针可以定义一个窗口，但无法同时界定一个区间的两个端点。因此，我们需要一个指针 i 来锚定所有子串的起点，然后用另外两个指针 l 和 r 去“扫描”出合法终点区间的左右边界。这三个指针各司其职，共同协作，将寻找 [j_min, j_max] 的过程从 O(N) 优化到了均摊 O(1)，从而保证了整体 O(N) 的时间复杂度。

>代码如下:

```cpp
#include <bits/stdc++.h>
using namespace std;
//CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<double> vd;
typedef vector<PII> vPII;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define out(x) cout << ((x) ? "YES" : "NO") << endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p<<1
#define rc p<<1|1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x)&(-x))
#define rep(i, x, n) for (ll i = x; i <= n; i++)
#define dep(i, x, n) for (ll i = x; i >= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps=1e-5;
const int N = 1e5 + 10,M=2*N,K=26;
const ll MOD = 1e9 + 7,Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template<typename T> bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template<typename T> bool cmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }
template<typename T> void sort_range(vector<T> &v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random { mt19937_64 rng; Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {} ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); } ll rand_ll(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); } int rand_int(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); } double rand_db(double l, double r) { return uniform_real_distribution<double>(l, r)(rng); } bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); } template<typename T> void shuffle(vector<T> &v) { std::shuffle(v.begin(), v.end(), rng); } };
ll qmi(ll a, ll b, ll p) { ll res = 1 % p; a %= p; while (b) { if (b & 1) res = res * a % p; a = a * a % p; b >>= 1; } return res; }
/*

}
*/
	   
       
void solve()
{
	ll n,na,nb; cin>>n>>na>>nb;
	string s; cin>>s;
	s=" "+s;
	ll cnta=0,cntb=0,ans=0;//记录区间内 a b字符的数量 ans记录合法的区间数
	for(int i = 1, ja = 1, jb = 1; i <= n; i++)
	{
		while(ja<=n&&cnta<na)
		{
			cnta+=s[ja]=='a';
			ja++;
		}
		while(jb<=n&&cntb+(s[jb]=='b')<nb)
		{
			cntb += ((s[jb]=='b'));
			jb++;
		}
		if(cnta>=na&&cntb<nb&&ja<=jb){
			ans+=jb-ja+1;
		}
		 /**
         * 准备处理下一个起点(i+1)：从当前计数中移除起点i处的字符
         * 这是因为下一轮循环i会递增，窗口起点变为i+1
         * 需要从计数中移除不再属于新窗口的字符s[i]
         */
		cnta-=(s[i]=='a');
		cntb-=(s[i]=='b');
	}
	cout<<ans<<endl;
}

int main()
{
	 IOS; 
		
	int _ = 1;
	// cin>>_;//如果是多组数据
	while (_--)
	{
		solve();
	}
	return 0;
}
```
### D - Neighbor Distance

<img width="1793" height="1003" alt="Image" src="https://github.com/user-attachments/assets/afcd8d87-3227-43e6-9bbc-4eef1c2baa00" />
这题思路简单就只需要正常模拟就行。


[容器不熟练的点这里复习](https://oi-wiki.org/lang/csl/associative-container/)


AC代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<double> vd;
typedef vector<PII> vPII;
#define IOS                  \
    ios::sync_with_stdio(0); \
    cin.tie(0);              \
    cout.tie(0);
#define out(x) cout << ((x) ? "YES" : "NO") << endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p << 1
#define rc p << 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define rep(i, x, n) for (ll i = x; i <= n; i++)
#define dep(i, x, n) for (ll i = x; i >= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
const int N = 1e5 + 10, M = 2 * N, K = 26;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template <typename T>
bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template <typename T>
bool cmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }
template <typename T>
void sort_range(vector<T> &v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random
{
    mt19937_64 rng;
    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
    ll rand_ll(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); }
    int rand_int(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); }
    double rand_db(double l, double r) { return uniform_real_distribution<double>(l, r)(rng); }
    bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
    template <typename T>
    void shuffle(vector<T> &v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
    ll res = 1 % p;
    a %= p;
    while (b)
    {
        if (b & 1)
            res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}
/*

*/

void solve()
{
    ll n, res = 0, x;
    cin >> n;
    set<ll> st;
    map<ll, ll> mp;
    cin >> x;
    st.insert(0);
    st.insert(x);
    mp[0] = x;
    mp[x] = x;
    res += 2 * x;
    cout << res << endl;
    for (int i = 1; i < n; i++)
    {
        cin >> x;
        vector<ll> h;
        auto it = st.lower_bound(x);
        if (it != st.end())
            h.push_back(*it);
        if (it != st.begin())
        {
            it--;
            h.push_back(*it);
        }
        st.insert(x);
        mp[x] = 2e9;
        for (auto &nxt : h)
        {
            res -= mp[nxt];                       // 从总和中去掉邻居旧的距离
            mp[nxt] = min(mp[nxt], abs(nxt - x)); // 更新邻居的距离
            res += mp[nxt];                       // 将邻居的新距离加回总和
            mp[x] = min(mp[x], abs(nxt - x));
        }
        res += mp[x];
        cout << res << endl;
    }
}

int main()
{
    IOS;

    int _ = 1;
    // cin>>_;//如果是多组数据
    while (_--)
    {
        solve();
    }
    return 0;
}
```
### E - Shift String
题意:
>您将获得由‘ 0 ’和‘ 1 ’组成的长度相等的字符串 A 和 B 。A 可以执行0次或多次以下操作。—将 A 的第一个字符移到末尾。求生成 A=B 所需的最小操作数。如果无论你怎么操作都不能做出 A=B ，那就打印 −1 。给你 T 个测试用例；找出每个问题的答案。

思路:

>我们先从最朴素的思路出发，操作是将A的第一个字符移动最后一个位置，显然这个过程具有周期性，我们不妨把A字符扩大一倍，然后控制首尾指针保证A串的长度，看看整个模拟过程是否有与B字符串相等的时候，如果没有输出-1，有则输出开头指针即可(默认字符串下标从1开始)。

代码如下:

```cpp
#include <bits/stdc++.h>
using namespace std;
//CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<double> vd;
typedef vector<PII> vPII;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define out(x) cout << ((x) ? "YES" : "NO") << endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p<<1
#define rc p<<1|1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x)&(-x))
#define rep(i, x, n) for (ll i = x; i <= n; i++)
#define dep(i, x, n) for (ll i = x; i >= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps=1e-5;
const int N = 2e6 + 10,M=2*N,K=26;
const ll MOD = 1e9 + 7,Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template<typename T> bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template<typename T> bool cmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }
template<typename T> void sort_range(vector<T> &v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random { mt19937_64 rng; Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {} ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); } ll rand_ll(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); } int rand_int(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); } double rand_db(double l, double r) { return uniform_real_distribution<double>(l, r)(rng); } bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); } template<typename T> void shuffle(vector<T> &v) { std::shuffle(v.begin(), v.end(), rng); } };
ll qmi(ll a, ll b, ll p) { ll res = 1 % p; a %= p; while (b) { if (b & 1) res = res * a % p; a = a * a % p; b >>= 1; } return res; }
/*
	
*/
	   
       
void solve()
{
	string a,b; cin>>a>>b;
	ll n=a.size();
	a+=a;
	ll cnt=-1;
	for(int i=0;i<n;i++){
		string s=a.substr(i,n);
		if(s==b){
			cnt=i;
			break;
		}
	}
	cout<<cnt<<endl;

}

int main()
{
	 IOS; 
		
	int _ = 1;
	 cin>>_;//如果是多组数据
	while (_--)
	{
		solve();
	}
	return 0;
}
```

然而朴素的模拟会TLE，于是我们想到我们曾写过的KMP算法，用于主串与模式串的匹配，正好符合题意。由于题目比较板，不会复习一下KMP算法即可AC，这里不对思路做多余的赘述了。
KMP解法如下:
```cpp#include <bits/stdc++.h>
using namespace std;
// CJX__//
typedef long long ll; // 不开long long 见祖宗
typedef unsigned long long ull;
typedef __int128 i128;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<double> vd;
typedef vector<PII> vPII;
#define IOS                  \
	ios::sync_with_stdio(0); \
	cin.tie(0);              \
	cout.tie(0);
#define out(x) cout << ((x) ? "YES" : "NO") << endl
#define mod(x, P) (((x) % (P) + (P)) % (P))
#define endl '\n'
#define gcd __gcd
#define lc p << 1
#define rc p << 1 | 1
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define rep(i, x, n) for (ll i = x; i <= n; i++)
#define dep(i, x, n) for (ll i = x; i >= n; i--)
#define mem(a, x) memset(a, x, sizeof a)
const double eps = 1e-5;
// N 的大小需要足够容纳 ' ' + B + '#' + A + A
// |A| <= 10^6, |B| <= 10^6, |A+A| <= 2*10^6
// 总长度约为 1 + 10^6 + 1 + 2*10^6 = 3*10^6 + 2, 所以 N 开大一点
const int N = 3e6 + 20;
const ll MOD = 1e9 + 7, Md3 = 998244353, Md7 = 1e9 + 7, Md9 = 1e9 + 9;
const ll base1 = 131, base2 = 13331;
const int dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1}, dy[8] = {0, 1, 0, -1, -1, 1, -1, 1};
const int ddx[8] = {1, 1, 2, 2, -1, -1, -2, -2}, ddy[8] = {2, -2, 1, -1, 2, -2, 1, -1};
template <typename T>
bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template <typename T>
bool cmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }
template <typename T>
void sort_range(vector<T> &v, int l, int r) { sort(v.begin() + l, v.begin() + r + 1); }
struct Random
{
	mt19937_64 rng;
	Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
	ull rand_ull(ull max_val = -1) { return rng() % (max_val + 1); }
	ll rand_ll(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(rng); }
	int rand_int(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); }
	double rand_db(double l, double r) { return uniform_real_distribution<double>(l, r)(rng); }
	bool rand_bool(double p = 0.5) { return bernoulli_distribution(p)(rng); }
	template <typename T>
	void shuffle(vector<T> &v) { std::shuffle(v.begin(), v.end(), rng); }
};
ll qmi(ll a, ll b, ll p)
{
	ll res = 1 % p;
	a %= p;
	while (b)
	{
		if (b & 1)
			res = res * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return res;
}

int pi[N];

void solve()
{
	string a, b;
	cin >> a >> b;

	if (a.size() != b.size())
	{
		cout << -1 << endl;
		return;
	}

	string t = a + a;
	string p = b;
	int m = p.size();
	if (m == 0)
	{
		cout << 0 << endl;
		return;
	}
	string s = " " + p + '#' + t;
	int lens = s.size() - 1;
	for (int i = 0; i <= lens; i++)  pi[i] = 0;
	
	for (int i = 2, j = 0; i <= lens; i++)
	{
		while (j > 0 && s[i] != s[j + 1])
		{
			j = pi[j];
		}
		if (s[i] == s[j + 1])
		{
			j++;
		}
		pi[i] = j;

		if (pi[i] == m)
		{

			int pos = i - 2 * m - 1;

			if (pos < m)
			{
				cout << pos << endl;
				return;
			}
		}
	}

	cout << -1 << endl;
}

int main()
{
	IOS;

	int T = 1;
	cin >> T; // 如果是多组数据
	while (T--)
	{
		solve();
	}
	return 0;
}

```


[KMP算法介绍](https://oi-wiki.org/string/kmp/)

由于我的KMP板子在其他博客难以查到，后续有时间再单独写一篇自己KMP的算法专栏，考虑到当前只是想写题解，这个后续有时间再补。

